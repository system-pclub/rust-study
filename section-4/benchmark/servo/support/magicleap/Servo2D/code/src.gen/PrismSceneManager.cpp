// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --
//
// THE CONTENTS OF THIS FILE IS GENERATED BY CODE AND
// ANY MODIFICATIONS WILL BE OVERWRITTEN
//
// -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING -- WARNING --

// %BANNER_BEGIN%
// ---------------------------------------------------------------------
// %COPYRIGHT_BEGIN%
//
// Copyright (c) 2018 Magic Leap, Inc. All Rights Reserved.
// Use of this file is governed by the Creator Agreement, located
// here: https://id.magicleap.com/creator-terms
//
// %COPYRIGHT_END%
// ---------------------------------------------------------------------
// %BANNER_END%

// %SRC_VERSION%: 1

#include <PrismSceneManager.h>

#include <ml_logging.h>

PrismSceneManager::CreateSpawnedSceneUserData PrismSceneManager::createSpawnedSceneUserData[scenes::numberOfExternalScenes];

PrismSceneManager::PrismSceneManager(lumin::Prism* prism)
: prism_(prism) {

  if (!prism_) {
    ML_LOG(Error, "PrismSceneManager nullptr prism");
    abort();
  }

  for (int i = 0; i < sizeof(sceneStates_)/sizeof(sceneStates_[0]); ++i) {
    sceneStates_[i] = SceneState::Unloaded;
  }
}

void PrismSceneManager::setSceneState(const SceneDescriptor & sceneDescriptor, SceneState newState) {

  const int sceneIndex = sceneDescriptor.getIndex();
  SceneState& sceneState = sceneStates_[sceneIndex];
  std::string& objectModelName = objectModelNames_[sceneIndex];

  if (sceneState == SceneState::Unloaded && (newState == SceneState::ResourceModelLoaded || newState == SceneState::ResourceAndObjectModelLoaded)) {
    if (!prism_->loadResourceModel(sceneDescriptor.getResourceModelPath())) {
      ML_LOG(Error, "PrismSceneManager failed to load resource model");
      abort();
    }
    sceneState = SceneState::ResourceModelLoaded;
  }

  if (sceneState == SceneState::ResourceModelLoaded && newState == SceneState::ResourceAndObjectModelLoaded) {
    std::string& objectModelName = objectModelNames_[sceneIndex];
    if (!prism_->loadObjectModel(sceneDescriptor.getSceneGraphPath(), objectModelName)) {
      ML_LOG(Error, "PrismSceneManager failed to load object model");
      abort();
    }
    sceneState = SceneState::ResourceAndObjectModelLoaded;
  }

  if (sceneState == SceneState::ResourceAndObjectModelLoaded && (newState == SceneState::ResourceModelLoaded || newState == SceneState::Unloaded)) {
    if (!prism_->unloadObjectModel(objectModelName)) {
      ML_LOG(Error, "PrismSceneManager failed to unload object model");
      abort();
    }
    sceneState = SceneState::ResourceModelLoaded;
    objectModelName.clear();
  }

  // Currently there is no effective way to unload the resource model  
}

SpawnedSceneBase* PrismSceneManager::spawnScene(const SceneDescriptor & sceneDescriptor) {

  lumin::Node* root = createNodeTree(sceneDescriptor);
  if (!root) {
    return nullptr;
  }

  const int index = sceneDescriptor.getIndex();
  CreateSpawnedScene css = createSpawnedScene[index];
  SpawnedSceneBase* const spawnedScene = (*css)(sceneDescriptor, root);
 
  CreateSpawnedSceneHandlers ch = createSpawnedSceneHandlers[index];
  SpawnedSceneHandlers* const handlers = (*ch)(*spawnedScene);
  spawnedScene->handlers = handlers;

  CreateSpawnedSceneUserData cssud = createSpawnedSceneUserData[sceneDescriptor.getIndex()];
  if (cssud) {
    spawnedScene->userData = (*cssud)(*spawnedScene);
  }
  return spawnedScene;
}

lumin::Node* PrismSceneManager::spawn(const SceneDescriptor & sceneDescriptor) {
  SpawnedSceneBase* spawnedSceneBase = spawnScene(sceneDescriptor);
  if (!spawnedSceneBase) {
    return nullptr;
  }
  lumin::Node* root = spawnedSceneBase->root;
  return root;
}

lumin::Node* PrismSceneManager::createNodeTree(const SceneDescriptor & sceneDescriptor) {
  setSceneState(sceneDescriptor, SceneState::ResourceAndObjectModelLoaded);
  const int sceneIndex = sceneDescriptor.getIndex();
  std::string& objectModelName = objectModelNames_[sceneIndex];

  lumin::Node* root = prism_->createAll(objectModelName);
  if (!root) {
    ML_LOG(Error, "PrismSceneManager failed to create the scene. Is the scene empty?");
    return nullptr;
  }

  return root;
}

void PrismSceneManager::setUserDataCreator(const SceneDescriptor & sceneDescriptor, CreateSpawnedSceneUserData cssud) {
  createSpawnedSceneUserData[sceneDescriptor.getIndex()] = cssud ;
}

