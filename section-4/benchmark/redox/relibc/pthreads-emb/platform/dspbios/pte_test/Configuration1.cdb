//! 
//# c64xx.cdb 5.23.14

object CACHE_L2 :: MEM {
    param iComment :: "Do not delete, in use by cache"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 1048576
    param len :: 0
    param iAllocHeap :: 0
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "Cache"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (if self.gNumOf > 0 {1} else {0})
    prop NoGen :: 0
    prop IsDirty :: ($a = self.gDirty, self.gDirty = 0, $a)
    prop dataSize :: 0
    prop error :: # ("Error: ", self.name, $1)
    prop warning :: ("Warning ...", self.name, $1)
    prop minBit :: ($a = 0, while (($1 & (1 << $a)) && $a < 32) {++$a}, $a)
    prop name :: ("<unnamed module>")
    prop numBit :: ($a = $b = 0, while ($a < 32) {if ($1 & (1 << $a)) {++$b} }, $b)
}

class ObjectMgr {
    isa Module
    prop CanCreate :: (if (self.gNumOf < self.maxObjs()) {self.localCanCreate()} else {self.warning("Maximum number of objects already created")})
    prop CanDelete :: (if (self.iDelMsg == "ok" || (self.iDelUser == self.gUser)) {if (self.iId >= 0 && self.iIsUsed) {self.localCanDelete()} else {self.warning("Object already deleted")}} else {self.warning(self.iDelMsg)})
    prop Create :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanCreate()) == "ok") {if (($a = self.localCreate()) == "ok") {if (self.iIsUsed == 0) {self.mkId(if $0 > 1 {$2} else {-1}), self.iIsUsed = 1, GlobalStatus.gDirty = 1, self.gDirty = 1} } } , (self.gUser = "USER"), $a)
    prop Delete :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanDelete()) == "ok") {if (($a = self.localDelete()) == "ok") {self.rmId(self.iId), self.iIsUsed = 0, GlobalStatus.gDirty = 1, self.gDirty = 1} } , (self.gUser = "USER"), $a)
    prop GetSetOf :: (self.gSetOf)
    prop GetNumOf :: (self.gNumOf)
    prop GetObjId :: (self.iId)
    prop GetPriority :: (self.iId)
    prop SetPriority :: (self.iId = $1)
    prop IsConfObj :: (self.iIsUsed)
    prop localCanCreate :: ("ok")
    prop localCanDelete :: ("ok")
    prop localCreate :: ("ok")
    prop localDelete :: ("ok")
    prop localInit :: (0)
    prop isFinite :: (if self.maxObjs() <= GBL.DSPWORDSIZE {1} else {0})
    prop mkId :: (if (self.isFinite()) {if ($1 < 0) {self.iId = self.minBit(self.gSetOf)} else {self.iId = $1}, (self.gSetOf |= (1 << self.iId))} else {self.iId = 0}, ++self.gNumOf, self.iId)
    prop rmId :: (if (self.isFinite()) {self.gSetOf &= ~(1 << self.iId)} , --self.gNumOf)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop isDriver :: (0)
    prop SortChildHierView :: (1)
}

type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (100)
    prop GlobalPropertyPage :: ("{9D3AD931-847B-11d0-A621-0000C070F3E9}")
    prop Status :: (# self.SeedVersion, # self.MinStackSize, # self.SysDataSize)
    global GENLIB :: "bioscfg.dll" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generation Library"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    global DATE :: "Fri Apr 04 15:41:02 2008" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global GCONFVERS :: "@(#)*** xdc-m66" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SysDataSize :: = ($a = 0, scan ($i; nil) {if ($i.dataSize() != nil) {$a = $a + $i.dataSize()} }, $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Estimated Data Size: %d"
        prop StatusField :: 1
        prop NoGen :: 1
    }
    global MinStackSize :: = ($a = ((2 * (2)) * 4), $a = $a + ((2 * (5)) * 4), $a = $a + ((0) * 4), $b = 0, scan ($i; CLK) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (2)) * 4) * $b), $b = 0, scan ($i; HWI) {if ($i.IsConfObj()) {if ($i != HWI_NMI && $i != HWI_RESET) {if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {$b++} } } }, $a = $a + (((12 + 14 + 2) * 4) * $b), $b = 0, scan ($i; SWI) {if ($i.IsConfObj()) {if ($i.priority > $b) {$b = $i.priority} } }, $a = $a + ((((2 * 2) + 18 + (2 * 4)) * 4) * $b), $b = 0, scan ($i; PRD) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (3)) * 4) * $b), $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Est. Min. Stack Size (MAUs): %d"
        prop StatusField :: 1
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ConfigWarnings :: = (if (self.MinStackSize > MEM.STACKSIZE) {"Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."} else {"None"}) { 
        prop Label :: "Warnings"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SeedVersion :: = "@(#)*** cuda-r14x" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

class EModule {
    isa Module
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class ModuleFolder {
    isa Module
    prop NoGen :: 1
}

type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (500)
    prop GlobalPropertyPage :: ("{B936FB91-52A5-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (501)
    prop GlobalPropertyPage :: ("{053C8F90-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (502)
    prop GlobalPropertyPage :: ("{053C8F91-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (503)
    prop GlobalPropertyPage :: ("{053C8F92-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (504)
    prop GlobalPropertyPage :: ("{053C8F93-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (505)
    prop GlobalPropertyPage :: ("{A2BCEC70-5365-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type PROJ {
    isa ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (201)
    prop GlobalHelpTopic :: (101)
    prop InstancePropertyPage :: ("{AC3C77D1-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D2-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ALIASALL :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate C Names for All Objects"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global IGNOREWARNING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Ignore Warnings"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Include File Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global OBJDIR :: "." { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object file directory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTEXE :: "out" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Executable File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTLIB :: "lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTASM :: "asm" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Assembly Language Source File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTOBJ :: "obj" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst projType :: "Executable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Executable,Library"
        prop Label :: "Target Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst projName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst useRpt :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RPT Instruction"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst minimizeSpace :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Optimize for Space over Time"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst tmx :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Avoid TMX Silicon Bugs"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    prop Label :: "Project File Manager"
    prop InstanceHelpTopic :: (BIOSHELP_PROJ_FILE_INSTANCE)
    prop GlobalHelpTopic :: (BIOSHELP_PROJ_FILE_GLOBAL)
    prop InstancePropertyPage :: ("{AC3C77D3-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D4-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst elemType :: "C Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C Source,ASM Source,Library,Linker Command File"
        prop Label :: "Input File Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Input File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "register,register+local,register+local+global,register+local+global+file"
        prop Label :: "Optimization Level"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst inline :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Inline Expansion"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst definitions :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Additional Definitions"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst iParent :: 0 { 
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 0
    prop GenLinkPrologue :: ("%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n--trampolines\n%25S%1S%22S-l%2S%23S%3S\n%24S%15S%4S%16S%18S%5S%6S%12S%7S%17S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _librarySuffix, _chipStr, _sioLibStr, _mpcLibStr, _bios6xLibStr, _bios6xClkType, _instStr, _rtsNameStr, _romStr, _biosRomStr, _logLibStr, _SKLibStr")
    prop poolStr :: (if (self.LINKWITHROM == 0) {""} else {if POOL.USEPOOL {""} else {"_POOL_config=0;\n"}})
    prop msgqStr :: (if (self.LINKWITHROM == 0) {""} else {if MSGQ.USEMSGQ {""} else {"_MSGQ_config=0;\n"}})
    prop GenLinkEpilogue :: ("%0t_GBL_CACHE = GBL_CACHE;\n%1S%2S\0, poolStr, msgqStr")
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
    prop GlobalHelpTopic :: (103)
    prop InstanceHelpTopic :: (103)
    prop InstancePropertyPage :: ("{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}")
    prop localInit :: (RTA_toHost.Create("HST"), RTA_fromHost.Create("HST"), RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"))
    prop chipcall :: ("ok")
    prop IsConfMod :: 1
    prop ucompare :: ($e = "ok", $a = ($1 >> 31) & 0x00000001, $b = ($2 >> 31) & 0x00000001, $c = $1 & 0x7fffffff, $d = $2 & 0x7fffffff, if ($a > $b) {$e = "gt"} else {if ($a == $b) {if ($c > $d) {$e = "gt"} else {if ($c == $d) {$e = "eq"} else {$e = "lt"}}} else {$e = "lt"}}, $e)
    prop L2Check :: (if (self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711) {self.PCC = "mapped", if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} , self.L2CacheSizeCheck()} else {if (self.DSPSUBTYPE == 6400) {self.PCC = "mapped", if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} , self.L2CacheSizeCheck()} else {if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0, self.L2CacheSizeCheck()} else {if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0, self.L2CacheSizeCheck()} }}})
    prop C621xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C621XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "SRAM") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "1-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x4000, CACHE_L2.len = 0x4000} else {if (self.L2MODEOPTS == "2-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.L2MODEOPTS == "3-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0xc000, CACHE_L2.len = 0xc000} else {if (self.L2MODEOPTS == "4-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} }}}}}, $e)
    prop C641xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C641XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (0k)") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C641XL2MODEOPTS == "4-way cache (256k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} }}}}}, $e)
    prop C64PL1PCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1PCFG = "32k", CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {if (self.C64PL1PCFG == "0k") {CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x0, CACHE_L1P.len = 0x0, CACHE_L1P.Delete("MEM")} else {if (self.C64PL1PCFG == "4k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x1000, CACHE_L1P.len = 0x1000} else {if (self.C64PL1PCFG == "8k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x2000, CACHE_L1P.len = 0x2000} else {if (self.C64PL1PCFG == "16k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x4000, CACHE_L1P.len = 0x4000} else {if (self.C64PL1PCFG == "32k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL1DCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1DCFG = "32k", CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {if (self.C64PL1DCFG == "0k") {CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x0, CACHE_L1D.len = 0x0, CACHE_L1D.Delete("MEM")} else {if (self.C64PL1DCFG == "4k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x1000, CACHE_L1D.len = 0x1000} else {if (self.C64PL1DCFG == "8k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x2000, CACHE_L1D.len = 0x2000} else {if (self.C64PL1DCFG == "16k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x4000, CACHE_L1D.len = 0x4000} else {if (self.C64PL1DCFG == "32k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL2CacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "0k") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "32k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C64PL2MODEOPTS == "64k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C64PL2MODEOPTS == "128k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C64PL2MODEOPTS == "256k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop L2CacheSizeCheck :: ($e = "ok", scan ($i; MEM) {if ($i == CACHE_L2) {if self.C621XL2CONFIGURE {$e = self.C621xL2CacheSizeCheck()} else {if self.C641XL2CONFIGURE {$e = self.C641xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711 {$e = self.C621xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6400 {$e = self.C641xL2CacheSizeCheck()} else {{CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")}}}}}} }, $e)
    prop setCPUClock :: ($e = "ok", if ($1 != self.CPUCLOCK) {$a = self.CPUCLOCK, self.CPUCLOCK = $1, if (GBL.CALLBACKOBJ != nil) {$e = GBL.CALLBACKOBJ.call()} , if ($e != "ok") {self.CPUCLOCK = $a, GBL.CALLBACKOBJ.call()} } , if ($e == "ok") {"ok"} else {self.error($e)})
    prop setL2MODE :: (if (self.L2MODEOPTS == "SRAM") {0x0} else {if (self.L2MODEOPTS == "1-way cache") {0x1} else {if (self.L2MODEOPTS == "2-way cache") {0x2} else {if (self.L2MODEOPTS == "3-way cache") {0x3} else {0x7}}}})
    prop setC641XL2MODE :: (if (self.C641XL2MODEOPTS == "4-way cache (0k)") {0x0} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {0x1} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {0x2} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {0x3} else {0x7}}}})
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (if (HST.RTDX == 1) {"lnkrtdx"} else {if (HST.DSM == 1) {"lnkdsm"} else {if (HST.EVM54 == 1) {"lnkevm54"} else {if (HST.BIOSLINK == 1) {"lnkbioslink"} else {"lnknone"}}}})
    prop _dsptype :: GBL.DSPTYPE
    prop _instStr :: if self.INSTRUMENTED {""} else {"_NONINST"}
    prop _rtsNameStr :: (self.RTSLIB)
    prop _biosLibStr :: "-lbios%20S%23S%8S %24t/* DSP/BIOS support */%0t\n"
    prop _compilerModel :: if self.ENDIAN == "big" {"e"} else {""}
    prop _librarySuffix :: (if (self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711 || self.DSPSUBTYPE == 6712 || self.DSPSUBTYPE == 6713) {if (self.ENDIAN == "big") {".a67e"} else {".a67"}} else {if (self.DSPSUBTYPE == 6400) {if (self.ENDIAN == "big") {".a64e"} else {".a64"}} else {if (self.DSPSUBTYPE == 6499) {if (self.ENDIAN == "big") {".a64Pe"} else {".a64P"}} else {if (self.DSPSUBTYPE == 6799) {if (self.ENDIAN == "big") {".a67Pe"} else {".a67P"}} else {if (self.ENDIAN == "big") {".a62e"} else {".a62"}}}}})
    prop _rtdxLibStr :: if RTDX.USERTDX == 0 {""} else {if RTDX.RTDXTYPE == "JTAG" {"-lrtdx64xx%9S.lib %24t/* RTDX support */%0t\n"} else {if RTDX.RTDXTYPE == "Simulator" {"-lrtdxsim%9S.lib %24t/* RTDX support */%0t\n"} else {"-lrtdxhs%9S.lib %24t/* RTDX support */%0t\n"}}}
    prop _rtsLibStr :: (if self.SPECIFYRTSLIB {"-l%21S%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711 || self.DSPSUBTYPE == 6712 || self.DSPSUBTYPE == 6713 {"-lrts6700%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6400 {"-lrts6400%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6799 {"-lrts67plus%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6499 {"-lrts64plus%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {"-lrts6200%9S.lib%24t/* C and C++ run-time library support */%0t\n"}}}}})
    prop _bios6xClkType :: (if self.CLKTYPE == 6000 {"C6000"} else {if self.CLKTYPE == 700 {"DA700"} else {if (self.CLKTYPE == 420 || self.CLKTYPE == 6424) {if self.USEIDMA0DISPATCHER {"DM420IDMA0"} else {"DM420"}} else {if self.CLKTYPE == 2430 {"2430"} else {if self.CLKTYPE == 6482 {"TCI6482"} else {if self.CLKTYPE == 6486 {"TCI6486"} else {if self.CLKTYPE == 6488 {"TCI6488"} else {if self.CLKTYPE == 442 {"DRA442"} else {if self.CLKTYPE == 3430 {"3430"} else {""}}}}}}}}})
    prop _bios6xLibStr :: ("-lbios%19S%23S%8S%24t/* BIOS clock specific library */%0t\n")
    prop _chipStr :: ""
    prop _mpcLibStr :: ""
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (if (MEM.LNKCMDFILE == "") {""} else {"-l%11S %24t/* User Specified Linker cmd file */%0t\n"})
    prop _sioLibStr :: if SIO.USEISSUERECLAIM == 1 {"-lsioir%23S%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n"} else {"-lsioboth%23S%8S %24t/* supports both SIO models */%0t\n"}
    prop _devLibStr :: "-ldrivers%23S%14S %24t/* device drivers support */%0t\n"
    prop _cslLibStr :: ""
    prop _chipType :: ""
    prop _logLibStr :: if LOG.TS {"-llog8%3S\n"} else {""}
    prop _romStr :: if self.LINKWITHROM {"-lromC672x.out\n-lromC672x.cmd\n"} else {""}
    prop _biosRomStr :: if self.LINKWITHROM {"_BIOSROM"} else {""}
    prop _SKLibStr :: ""
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PRODUCT :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop EnvField :: 1
    }
    global CALLBACKOBJ :: CLK { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c64xx" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CPUCLOCK :: 720.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PROCID :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Processor ID (PROCID)"
        prop JSName :: "PROCID"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CLKIN :: = 20000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: "Board Clock in KHz (Informational Only)"
        prop JSName :: "CLKIN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global FREQ :: 720000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MIPS :: 720.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = self.MIPS, $b = if (GBL.DSPTYPE == 62) {$1} else {$1 * 2}, $e = "ok", self.MIPS = $1, self.FREQ = int(self.MIPS * 1000), if (($e = self.setCPUClock($b)) != "ok") {self.MIPS = $a} , $e)
    }
    global OSTYPE :: "BIOS" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPTYPE :: 62 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global SPECIFYRTSLIB :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify RTS library"
        prop JSName :: "SPECIFYRTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
    }
    global RTSLIB :: "rts6400_eh.lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Run-Time Support Library"
        prop JSName :: "RTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: self.SPECIFYRTSLIB
    }
    global DSPSUBTYPE :: 6400 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "6400"
        prop Label :: "DSP Type"
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (self.DSPSUBTYPE = $1, self.L2Check(), "ok")
        prop NoGen :: 0
    }
    global CLKTYPE :: 6000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CLK Type"
        prop JSName :: "CLKTYPE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CHIPTYPE :: "6416" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DM642,6410,6412,6413,6414,6415,6416,custom,other"
        prop Label :: "Chip Support Library (CSL)"
        prop JSName :: "CHIPTYPE"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (if ($1 == "6201" || $1 == "6202" || $1 == "6203" || $1 == "6204" || $1 == "6205") {self.DSPSUBTYPE = 6200} else {if ($1 == "6701") {self.DSPSUBTYPE = 6700} else {if ($1 == "6211") {self.DSPSUBTYPE = 6211} else {if ($1 == "6711" || $1 == "6712" || $1 == "6713" || $1 == "DA610") {if ($1 == "6711") {self.DSPSUBTYPE = 6711} , if ($1 == "6712") {self.DSPSUBTYPE = 6712} , if ($1 == "6713") {self.DSPSUBTYPE = 6713} } else {if ($1 == "DM642" || $1 == "6412" || $1 == "6414" || $1 == "6415" || $1 == "6416" || $1 == "6410" || $1 == "6413") {self.DSPSUBTYPE = 6400} }}}}, self.CHIPTYPE = $1, self.L2Check(), $e = "ok", if (GBL.CHIPCHAIN != nil) {$e = GBL.CHIPCHAIN.chipcall()} , $e)
    }
    global DISPCALLCSLCFGINIT :: = (self.CHIPTYPE != "other" && self.CHIPTYPE != "custom") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: self.SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C62XX" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPARITHMETIC :: = (if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {"FLOAT"} else {"FIXED"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {32} else {16}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (if GBL.DSPTYPE == 62 {8} else {if GBL.DSPSUBTYPE == 5599 {8} else {GBL.DSPWORDSIZE}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DATAPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {16} else {if (GBL.DSPTYPE == 55) {if (GBL.MEMORYMODEL == "SMALL") {16} else {23}} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {if (GBL.CALLMODEL == "near") {16} else {24}} else {if (GBL.DSPTYPE == 55) {24} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENDIAN :: "little" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "little,big"
        prop Label :: "DSP Endian Mode"
        prop JSName :: "ENDIANMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.ENDIAN = $1, "ok")
    }
    global BIGENDIAN :: = if self.ENDIAN == "little" {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global AUTOINIT :: "ROM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {self.USERINITFXN = @_FXN_F_nop, self.USERINIT = $1} else {self.USERINIT = $1}, "ok")
    }
    global USERINITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: self.USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENABLEINST :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEINST) {if ($1) {RTA_toHost.Create("HST"), RTA_fromHost.Create("HST"), RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = self.OLDAUTOCALCULATE} else {if (self.LINKWITHROM) {self.LINKWITHROM = 0} , RTA_toHost.Delete("HST"), RTA_fromHost.Delete("HST"), RTA_dispatcher.Delete("HST"), IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), self.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0}, self.ENABLEINST = $1} , "ok")
    }
    global INSTRUMENTED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Instrumented BIOS library"
        prop JSName :: "INSTRUMENTED"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CGENERATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLEDLL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Dynamic Loading"
        prop JSName :: "ENABLEDLL"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global PCC :: "mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Program Cache Control - CSR(PCC)       "
        prop JSName :: "CSRPCC"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6400) {0} else {1}
        prop NoGen :: 1
        prop TabName :: "620x/670x"
    }
    global DCC :: "mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Data Cache Control"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "620x/670x"
    }
    global PCACHE :: = (if (self.PCC == "mapped") {0x0000} else {if (self.PCC == "cache enable") {0x0040} else {if (self.PCC == "cache freeze") {0x0060} else {0x0080}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DCACHE :: = (if (self.DCC == "mapped") {0x0000} else {if (self.DCC == "cache enable") {0x0008} else {if (self.DCC == "cache freeze") {0x000c} else {0x0010}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CACHE :: = (self.PCACHE | self.DCACHE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global C621XL2CONFIGURE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "621x/671x - Configure L2 Memory Settings"
        prop JSName :: "C621XCONFIGUREL2"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6712 || GBL.DSPSUBTYPE == 6713) {1} else {0}
        prop TabName :: "621x/671x"
        prop Set :: ($e = "ok", self.C621XL2CONFIGURE = $1, self.PCC = "mapped", $e = self.L2CacheSizeCheck(), $e)
        prop NoGen :: 1
    }
    global C641XL2CONFIGURE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x - Configure L2 Memory Settings"
        prop JSName :: "C641XCONFIGUREL2"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400) {1} else {0}
        prop TabName :: "641x"
        prop Set :: ($e = "ok", self.C641XL2CONFIGURE = $1, self.PCC = "mapped", $e = self.L2CacheSizeCheck(), $e)
        prop NoGen :: 1
    }
    global L2CONFIGURE :: = (if GBL.DSPSUBTYPE == 6400 {self.C641XL2CONFIGURE} else {self.C621XL2CONFIGURE}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure L2 Cache Control (c6x1x support)"
        prop Visible :: 0
        prop NoGen :: 0
    }
    global C621XPCC :: "Cache Enabled - Direct Mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "Program Cache Control - CSR(PCC)                     "
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "621x/671x"
    }
    global C641XPCC :: "Cache Enabled - Direct Mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "641x - Program Cache Control - CSR(PCC)"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2MODEOPTS :: = "SRAM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Mode - CCFG(L2MODE)"
        prop JSName :: "C621XCCFGL2MODE"
        prop Enum :: "SRAM,1-way cache,2-way cache,3-way cache,4-way cache"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6712 || GBL.DSPSUBTYPE == 6713) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "621x/671x"
        prop Set :: ($i = self.L2MODEOPTS, self.L2MODEOPTS = $1, $e = self.L2CacheSizeCheck(), if ($e != "ok") {self.L2MODEOPTS = $i} , $e)
    }
    global C641XL2MODEOPTS :: "4-way cache (0k)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x L2 Mode - CCFG(L2MODE)"
        prop Enum :: "4-way cache (0k),4-way cache (32k),4-way cache (64k),4-way cache (128k),4-way cache (256k)"
        prop JSName :: "C641XCCFGL2MODE"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
        prop Set :: ($i = self.C641XL2MODEOPTS, self.C641XL2MODEOPTS = $1, $e = self.L2CacheSizeCheck(), if ($e != "ok") {self.C641XL2MODEOPTS = $i} , $e)
    }
    global L2MODE :: = (if GBL.DSPSUBTYPE == 6400 {self.setC641XL2MODE()} else {self.setL2MODE()}) { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Mode - CCFG(L2MODE) Values"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2PRIORITY :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Requestor Priority - CCFG(P)"
        prop Enum :: "0,1"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2MARMASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "L2 MAR0-15 - bitmask used to initialize MARs"
        prop JSName :: "C621XMAR"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6712 || GBL.DSPSUBTYPE == 6713) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "621x/671x"
    }
    global SUPPORTCSL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.TRCMASKVALUE = 0xDBEF} else {self.TRCMASKVALUE = 0x4000}, self.ENABLEALLTRC = $1, "ok")
    }
    global TRCMASKVALUE :: 56303 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT :: = self.DISPCALLCSLCFGINIT { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LINKWITHROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link with ROM"
        prop JSName :: "LINKWITHROM"
        prop Visible :: 0
        prop Writable :: if (self.DSPSUBTYPE == 6799 && self.ENABLEINST) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1) {$e = self.error("This BIOS version does not support linking with ROM.")} , $e)
    }
    global C641XL2PRIORITY :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK1 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR96-111 - bitmask controls EMIFB CE space"
        prop JSName :: "C641XMAREMIFB"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK2 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR128-143 - bitmask controls EMIFA CE0 space"
        prop JSName :: "C641XMARCE0"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK3 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR144-159 - bitmask controls EMIFA CE1 space"
        prop JSName :: "C641XMARCE1"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK4 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR160-175 - bitmask controls EMIFA CE2 space"
        prop JSName :: "C641XMARCE2"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK5 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR176-191 - bitmask controls EMIFA CE3 space"
        prop JSName :: "C641XMARCE3"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2REQPRIORITY :: "urgent" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x L2 Requestor Priority Queue - CCFG(P)"
        prop JSName :: "C641XCCFGP"
        prop Enum :: "urgent,high,medium,low"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop Set :: (self.L2REQPRIORITY = $1, if (self.L2REQPRIORITY == "urgent") {self.C641XL2PRIORITY = 0} else {if (self.L2REQPRIORITY == "high") {self.C641XL2PRIORITY = 1} else {if (self.L2REQPRIORITY == "medium") {self.C641XL2PRIORITY = 2} else {self.C641XL2PRIORITY = 3}}}, "ok")
        prop TabName :: "641x"
    }
    global L2CONFIGALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure Priority Queues"
        prop JSName :: "C641XSETL2ALLOC"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1)
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2ALLOC0 :: 6 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on URGENT Queue (L2ALLOC0)"
        prop JSName :: "C641XL2ALLOC0"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC1 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on HIGH Queue (L2ALLOC1)"
        prop JSName :: "C641XL2ALLOC1"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC2 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on MEDIUM Queue (L2ALLOC2)"
        prop JSName :: "C641XL2ALLOC2"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC3 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on LOW Queue (L2ALLOC3)"
        prop JSName :: "C641XL2ALLOC3"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC :: = ((self.L2ALLOC0) | (self.L2ALLOC1 << 4) | (self.L2ALLOC2 << 8) | (self.L2ALLOC3 << 12)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 0
    }
}

type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (108)
    prop InstanceHelpTopic :: (208)
    prop InstancePropertyPage :: ("{3D658E70-05E7-11d0-BD44-0020AFEE33C8}")
    prop GlobalPropertyPage :: ("{3D658E71-05E7-11d0-BD44-0020AFEE33C8}")
    prop heapLabelStr :: (self.iHeapId)
    prop GenLinkPrologue :: (if (GBL.DSPTYPE == 55) {"-stack 0x%1x\n-sysstack 0x%2x\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz"} else {"-stack 0x%1x\nMEMORY {%4t\0, _stackSize"})
    prop _stackSize :: MEM.STACKSIZE
    prop AllocType :: (if (self.REUSE == 0 && self.USERCMD == 0) {"19\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 0 && self.USERCMD == 1) {"9\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 1 && self.USERCMD == 0) {"18\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {"8\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"}}})
    prop _firstPlace :: 0
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace :: (0x7fffffff / 2)
    prop _sysinitPlace :: (0x7fffffff / 2)
    prop _argsString :: ("%8t .args: align=4 fill=0 {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString :: ("%8t .bss:     {}")
    prop _farString :: ("%8t .far:     {}")
    prop _cinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CINITSEG == MEM.LOADCINITSEG) {"%8t .cinit:    {}"} else {"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"}} else {"%8t .cinit:    {}"})
    prop _pinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.PINITSEG == MEM.LOADPINITSEG) {"%8t .pinit:   {}"} else {"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"}} else {"%8t .pinit:   {}"})
    prop _trcinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {"%8t .trcdata:   {}"} else {"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"}} else {"%8t .trcdata:    {}"})
    prop _gblinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {"%8t .gblinit:   {}"} else {"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"}} else {"%8t .gblinit:    {}"})
    prop _dataString :: ("%8t .data:    {}")
    prop _constString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {"%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"} else {"%8t .const: align = 0x8 {} load > %1s run\0, _loadconstSeg"}} else {"%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"})
    prop _switchString :: (if (self.ENABLELOADSEG == 1) {if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {"%8t .switch:   {}"} else {"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"}} else {"%8t .switch:    {}"})
    prop _sysmemString :: ("%8t .sysmem:  {}")
    prop _cioString :: ("%8t .cio:     {}")
    prop _memObjString :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (if ((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {"%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"} else {"%8t .sysdata: {}"})
    prop _sysinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.INITSEG == MEM.LOADINITSEG) {"%8t .sysinit:   {}"} else {"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"}} else {"%8t .sysinit:    {}"})
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {"%8t .text:    {}"} else {"%8t .text:    {} load > %1s, run\0, _loadtextSeg"}} else {"%8t .text:    {}"})
    prop _frtString :: ("%8t frt:    {}")
    prop _biosString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {"%8t .bios:    {}"} else {"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"}} else {"%8t .bios:    {}"})
    prop _stackString :: (if (GBL.DSPTYPE == 62) {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 4 & ~7;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"} else {if (GBL.DSPTYPE == 54) {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"} else {if (GBL.DSPTYPE == 55) {"%8t GROUP { \n%16t .sysstack :  align = 0x4 {%12t\n %16t GBL_sysstackbeg = .;\n %16t *(.sysstack)\n %16t GBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n %16t _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n %16t_HWI_SYSSTKBOTTOM = (GBL_sysstackend+1);\n%16t} \n%16t .stack: align = 0x4 {%12t\n %16t GBL_stackbeg = .;\n %16t *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n %16t _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n %16t _HWI_STKTOP = (GBL_stackbeg);%16t\n }%8t\n } BLOCK(0x20000), run \0, _cmd55stksz, _cmd55systksz"} else {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"}}})
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: ("%0t}")
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (if (self.iAllocHeap == 1) {"1\0, _instAllocDesc, _objMemSeg, _placement"} )
    prop _instAllocDesc :: (if self.INITSEG.iAllocHeap && self.REUSE && self.INITSEG == self {"%8t GROUP {%12t\n .sysinitgap {. += 0x%2x;}\n .sysinit:\n .%0r$heap: {%16t\n _%0r_base = %0r$B;\n _%0r_length = %0r$L;\n . += 0x%1x;%12t\n }%8t\n } START(%0r$B), SIZE(%0r$L)\0, _heapsize, _sysinitgap, _heaplen"} else {"%8t .%0r$heap: {%12t\n %0r$B = .;\n _%0r_base = .;\n %0r$L = 0x%2x;\n _%0r_length = 0x%2x;\n . += 0x%1x;%8t\n }\0, _heapsize, _heaplen"})
    prop _objMemSeg :: self
    prop _placement :: 0x7fffffff - 1
    prop _heapsize :: (self.iHeapSize)
    prop _heaplen :: (self.iHeapSize)
    prop _sysinitgap :: 2 * 4
    prop GenInstLink :: (if GBL.DSPTYPE == 62 {"%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"} else {if GBL.DSPTYPE == 55 {"PAGE %3d: %16t%0r: %26torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len, _page"} else {"PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"}})
    prop localInit :: ($d = "ok", scan ($i; MEM) {if ($i.space == "code" && $i.iAllocHeap == 1) {$d = self.error("Code memory cannot have a heap")} }, if (self.SEGZERO.iAllocHeap == 1) {self.SEGZERO.iReqHeapCount++} else {$d = self.error("Segment for DSP/BIOS objects must be a memory segment with a heap")}, if (self.MALLOCSEG.iAllocHeap == 1) {self.MALLOCSEG.iReqHeapCount++} else {$d = self.error("Segment for malloc()/free() must be a memory segment with a heap")}, $d)
    prop _page :: (self.page)
    prop _origin :: (self.base)
    prop _len :: (self.len)
    prop maxObjs :: (32767)
    prop codeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {(($1.space == "code") || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 54 {($1.space == "code")} else {if GBL.DSPTYPE == 28 {($1.space == "code")} else {if GBL.DSPTYPE == 55 {(($1.space == "code") || ($1.space == "code/data"))} else {($1.space == "code/data")}}}}})
    prop dataMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {if GBL.DSPTYPE == 28 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {(($1.space == "code/data") && ($1 != MEM_NULL))}}}}})
    prop dataNullMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 54 {$1.space != "code" && $1.space != "io"} else {if GBL.DSPTYPE == 28 {$1.space != "code" && $1.space != "io"} else {if GBL.DSPTYPE == 55 {$1.space == "data" || $1.space == "code/data"} else {$1.space == "code/data"}}}}})
    prop dataCodeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {$1.space == "code" && $1 != MEM_NULL} else {if GBL.DSPTYPE == 28 {$1.space == "code" && $1 != MEM_NULL} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {$1.space == "code/data" && $1 != MEM_NULL}}}}})
    prop memWritable :: (self.iIsModifiable && self.iDelUser != "MEM")
    prop validate :: ($e = self.checkMemOverlap($1), if ($e == "ok") {$e = self.checkHeapSize($1)} , if ($e == "ok") {$e = self.checkHeapSeg($1)} , $e)
    prop checkHeapSeg :: ($e = "ok", if ($1 == MEM_NULL && MEM.NOHEAPS == 0) {if (MEM.MALLOCSEG == MEM_NULL) {$e = ("Heaps are enabled, but the segment for malloc (MEM.MALLOCSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.MALLOCSEG to it.")} , if (MEM.SEGZERO == MEM_NULL) {$e = ("Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.")} } , $e)
    prop checkHeapSize :: ($e = "ok", if (MEM.NOHEAPS == 0) {if ($1.iAllocHeap && $1 != MEM_NULL) {if ($1.iHeapSize > $1.len) {$e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")} } } , $e)
    prop checkMemOverlap :: ($e = "ok", if ($1 != MEM_NULL && $1.iIsUsed == 1) {if ($1.len == 0) {$a = $1.base} else {$a = ($1.base + $1.len - 1)}, scan ($j; MEM) {if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 && (GBL.DSPTYPE == 62 || $1.space == $j.space)) {if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {$b = $j.base, if ($j.len == 0) {$c = $j.base} else {$c = ($j.base + $j.len - 1)}, if ($a >= $b && $1.base <= $c) {$e = ("MEM segment %s: overlaps with another segment or cache configuration."), break} } } }} , $e)
    prop _spaceEnum :: (self.ENUMSPACE)
    prop checkHeapId :: ($e = "ok", scan ($i; MEM) {if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {$e = self.error("This identifier label is already in use"), break} }, $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap :: = ($a = 0, scan ($i; MEM) {if ($i != MEM_NULL) {$a += $i.iAllocHeap} }, $a) { 
        prop NoGen :: 0
    }
    global REUSE :: = (if self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1 {self.SAVEREUSE} else {0}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reuse Startup Code Space"
        prop JSName :: "REUSECODESPACE"
        prop Visible :: 1
        prop Writable :: self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1
        prop NoGen :: 1
        prop Set :: (self.SAVEREUSE = $1, "ok")
    }
    global SAVEREUSE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    global doCheckOverlap :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MAPSELECT :: "Map 1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Map Mode"
        prop JSName :: "MAPMODE"
        prop Enum :: "Map 0,Map 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ARGSSIZE :: 4 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Argument Buffer Size"
        prop JSName :: "ARGSSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("The 'arguments' section must have at least 4 words.")} else {self.ARGSSIZE = $1, "ok"})
    }
    global ARGSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Argument Buffer Section (.args)"
        prop JSName :: "ARGSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global BIOSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "BIOS Code Section (.bios)"
        prop JSName :: "BIOSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: if GBL.DSPTYPE == 54 {0x01 | 0x02} else {0x02}
        prop Label :: "Stack Size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {self.STACKSIZE = ($1 & -2)} else {if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE == 5599)) {self.STACKSIZE = ($1 & -4)} else {self.STACKSIZE = $1}}, "ok")
        prop PropSetOkUserMsg :: if (MEM.STACKSIZE < GlobalStatus.MinStackSize) {"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!"} else {"ok"}
    }
    global USERCMD :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User .cmd File For Compiler Sections"
        prop JSName :: "USERCOMMANDFILE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Stack Section (.stack)"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global ENABLELOADSEG :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
        prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - BIOS Code Section (.bios)"
        prop JSName :: "LOADBIOSSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global INITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Startup Code Section (.sysinit)"
        prop JSName :: "SYSINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - Startup Code Section (.sysinit)"
        prop JSName :: "LOADSYSINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "GBLINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "TRC Initial Value (.trcdata)"
        prop JSName :: "TRCDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "LOADGBLINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - TRC Initial Value (.trcdata)"
        prop JSName :: "LOADTRCDATASEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SYSDATASEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Kernel State (.sysdata)"
        prop JSName :: "SYSDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
        prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No Dynamic Memory Heaps"
        prop JSName :: "NOMEMORYHEAPS"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.SEGZERO.iReqHeapCount--, self.SEGZERO = MEM_NULL, self.MALLOCSEG.iReqHeapCount--, self.MALLOCSEG = MEM_NULL, TSK.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, scan ($i; MEM) {if ($i.iAllocHeap && $i != MEM_NULL) {$i.iAllocHeap = 0, $i.iHeapSize = 0} }} , self.NOHEAPS = $1, "ok")
        prop PropSetOkUserMsg :: if (MEM.NOHEAPS == 1) {"Currently specified heaps no longer valid"} else {"Please reconfigure heaps under individual mem segments"}
    }
    global SEGZERO :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For DSP/BIOS Objects"
        prop JSName :: "BIOSOBJSEG"
        prop Visible :: 1
        prop Writable :: MEM.NOHEAPS == 0
        prop NoGen :: 0
        prop Set :: (if (self.SEGZERO.iReqHeapCount > 0) {self.SEGZERO.iReqHeapCount--} , self.SEGZERO = $1, self.SEGZERO.iReqHeapCount++, "ok")
    }
    global MALLOCSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
        prop JSName :: "MALLOCSEG"
        prop Visible :: 1
        prop Writable :: (MEM.NOHEAPS == 0)
        prop NoGen :: 0
        prop Set :: (if (self.MALLOCSEG.iReqHeapCount > 0) {self.MALLOCSEG.iReqHeapCount--} , self.MALLOCSEG = $1, self.MALLOCSEG.iReqHeapCount++, "ok")
    }
    global USEMPC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Memory Protection Controller module"
        prop JSName :: "USEMPC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global LNKCMDFILE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TEXTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Text Section (.text)"
        prop JSName :: "TEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Load Address - Text Section (.text)"
        prop JSName :: "LOADTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SWITCHSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Switch Jump Tables (.switch)"
        prop JSName :: "SWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Switch Jump Tables (.switch)"
        prop JSName :: "LOADSWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BSSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.bss)"
        prop JSName :: "BSSSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global FARSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.far)"
        prop JSName :: "FARSEG"
        prop Visible :: if GBL.DSPTYPE == 62 {1} else {0}
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Data Initialization Section (.cinit)"
        prop JSName :: "CINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Data Initialization Section (.cinit)"
        prop JSName :: "LOADCINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global PINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "C Function Initialization Table (.pinit)"
        prop JSName :: "PINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADPINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - C Function Initialization Table (.pinit)"
        prop JSName :: "LOADPINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global CONSTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Constant Sections (.const, .printf)"
        prop JSName :: "CONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Load Address - Constant Sections (.const, .printf)"
        prop JSName :: "LOADCONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global DATASEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.data)"
        prop JSName :: "DATASEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.cio)"
        prop JSName :: "CIOSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
        prop Set :: (self.CIOSEG = $1, self.SYSMEMSEG = $1, "ok")
    }
    global SYSMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.sysmem)"
        prop JSName :: "SYSMEMSEG"
        prop Visible :: 0
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory (.hwi)"
        prop JSName :: "HWISEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.STUBMEMSEG = $1, HWI.STUBMEMSEG = $1, "ok")
    }
    global LOADSTUBMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - Function Stub Memory (.hwi)"
        prop JSName :: "LOADHWISEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global VECMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "HWIVECSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.VECMEMSEG = $1, HWI.VECMEMSEG = $1, GlobalStatus.gDirty = 1, if ($1.base == 0) {HWI.GENERATE_RESET_VEC = 0} , "ok")
    }
    global LOADVECMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "LOADHWIVECSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop JSName :: "RTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.RTDXTEXTMEMSEG = $1, RTDX.TEXTMEMSEG = $1, "ok")
    }
    global LOADRTDXTEXTMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
        prop JSName :: "LOADRTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global ENUMSPACE :: = if GBL.DSPTYPE == 62 {"code,data,code/data,reserved"} else {if GBL.DSPTYPE == 54 {"code,data,io,other,reserved"} else {if GBL.DSPTYPE == 28 {"code,data,io,other,reserved"} else {if GBL.DSPTYPE == 55 {"code/data,code,data,io,reserved"} else {"code/data,io,reserved"}}}} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "ENUMSPACE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst base :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%06x"}
        prop Style :: 0x02
        prop Label :: "base"
        prop JSName :: "base"
        prop Visible :: 1
        prop Writable :: (self.iIsModifiable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", $a = self.base, self.base = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.base = $a} } , $e)
    }
    inst len :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x08
        prop Label :: "len"
        prop JSName :: "len"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 0
        prop Set :: ($e = "ok", $a = self.len, self.len = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.len = $a} } , "ok")
    }
    inst page :: = (if GBL.DSPTYPE == 62 {-1} else {if GBL.DSPTYPE == 55 {(if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {0}}})} else {if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {3}}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iAllocHeap :: if MEM.NOHEAPS == 1 {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
        prop JSName :: "createHeap"
        prop Visible :: 1
        prop Writable :: (self.space == "data" || self.space == "code/data") && (MEM.NOHEAPS == 0) && self.memWritable
        prop NoGen :: 0
        prop Set :: ($a = "ok", if ($1 == 0 && self.iReqHeapCount > 0) {self.error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")} else {if ($1 == 0) {self.iUserHeapId = 0, self.iHeapId = @segment_name} , self.iAllocHeap = $1, MEM.gDirty = 1, $a})
    }
    inst iHeapSize :: 0x8000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x02
        prop Label :: "heap size"
        prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (self.iHeapSize = $1, "ok")
        prop NoGen :: 1
    }
    inst iSegZero :: = MEM.SEGZERO
    inst iUserHeapId :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "enter a user defined heap identifier label"
        prop JSName :: "enableHeapLabel"
        prop Set :: (if ($1 == 0) {self.iHeapId = @segment_name} , self.iUserHeapId = $1, "ok")
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0)
        prop NoGen :: 1
    }
    inst iHeapId :: @segment_name { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "heap identifier label"
        prop JSName :: "heapLabel"
        prop Set :: ($e = self.checkHeapId($1), if ($e == "ok") {self.iHeapId = $1} , $e)
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0) && (self.iUserHeapId)
        prop Visible :: 1
        prop NoGen :: 0
    }
    inst iReqHeapCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst space :: (if GBL.DSPTYPE == 55 {"code/data"} else {"data"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: MEM._spaceEnum()
        prop JSName :: "space"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 != "data" && $1 != "code/data" && self.iAllocHeap == 1) {$e = self.error("Cannot select this space if a heap will be created")} else {$a = self.space, self.space = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.space = $a} } }, $e)
    }
    inst dynamicLoading :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reserved for dynamic loading"
        prop JSName :: "dynamicLoading"
        prop Visible :: GBL.ENABLEDLL
        prop Writable :: GBL.ENABLEDLL
        prop NoGen :: 1
    }
    inst iIsModifiable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 0
    param len :: 0
    param iAllocHeap :: 1
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _objMemDesc, _memSeg, _placement"} )
    prop _objMemDesc :: ("%8t .obj: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type BUF {
    isa ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer Manager"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (421)
    prop GlobalHelpTopic :: (321)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,      _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t.buf:{}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$data: align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength")
    prop _objAlign :: self.align
    prop _instMemSeg :: self.bufseg
    prop _buflength :: (self.postalignsize * self.bufcount)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"buf.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far BUF_Obj %0r;\n\0"} else {"extern BUF_Obj %0r;\n\0"})
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = ((7 + 3) * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = ((7 + 4) * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = ((7 + 3) * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (7 + 4)} , if (GBL.DSPTYPE == 28) {$a = (12 + 6)} , $a)
    prop dataSize :: ($d = 0, scan ($i; BUF) {if ($i.IsConfObj()) {$d += $i.len} , $d += BUF.objectSize}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Memory segment for buffer pool"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst bufcount :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer count"
        prop JSName :: "bufCount"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (self.bufcount = $1, self.postalignsize = (self.size + (self.align - 1)) & ~(self.align - 1), self.len = $1 * self.postalignsize, "ok")
    }
    inst size :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer size (MADUs)"
        prop JSName :: "size"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 8) {self.error("Size should be atleast 8 bytes")} else {self.size = $1, self.postalignsize = ($1 + (self.align - 1)) & ~(self.align - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst align :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer alignment(Power of 2)"
        prop JSName :: "align"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 4) {self.error("Alignment should be atleast 4 ")} else {self.align = $1, self.postalignsize = (self.size + ($1 - 1)) & ~($1 - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst len :: self.size { 
        prop Label :: "Buffer pool length (MADUs)"
        prop JSName :: "len"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst postalignsize :: self.size { 
        prop Label :: "Buffer size after alignment (MADUs)"
        prop JSName :: "postalignsize"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type POOL {
    isa Module
    prop Visible :: 1
    prop name :: "POOL"
    prop Label :: "POOL - Allocator Manager"
    prop IsConfMod :: self.USEPOOL
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop GlobalHelpTopic :: (324)
    prop InstanceHelpTopic :: (424)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "MEM,BUF"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEPOOL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Allocator Manager"
        prop JSName :: "ENABLEPOOL"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (202)
    prop GlobalHelpTopic :: (102)
    prop InstancePropertyPage :: ("{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}")
    prop objectSize :: (if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {$a = (2 * 4)} else {$a = (1 * 4)}, $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {\n%8t \n CLK_F_gethtime = %5s;\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s \0, name, _objSize, _memSeg, _linkString, clkFxn, _clkStartFxn")
    prop _clkStartFxn :: if (GBL.SUPPORTCSL && self.USETIMER) {@_CLK_start6x} else {@FXN_F_nop}
    prop GenLinkEpilogue :: ("%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TDDR = CLK_TDDR;\n\0")
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no CLK objs */"}
    prop _memSeg :: CLK.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop clkFxn :: if (self.USETIMER == 1) {self.CLKFXN} else {@FXN_F_zero}
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (if (GBL.CALLBACKOBJ != CLK) {CLK.gGBLChain = GBL.CALLBACKOBJ, GBL.CALLBACKOBJ = CLK} )
    prop dataSize :: (self.objectSize() * (CLK.gNumOf + 1))
    prop localCanCreate :: (if self.USETIMER {"ok"} else {self.error("The CLK Manager must be enabled before inserting a CLK")})
    prop localCreate :: (CLK.HOOKFXN = @HWI_F_dispatch, self.seizeHwi(self.WHICHHWI), "ok")
    prop localDelete :: (if (self.gNumOf == 1) {if (GBL.CALLMODEL == "far") {CLK.HOOKFXN = @CLK_F_frete, self.seizeHwi(self.WHICHHWI)} else {CLK.HOOKFXN = @CLK_F_rete, self.seizeHwi(self.WHICHHWI)}} , "ok")
    prop adjustPrd :: (if GBL.DSPTYPE == 62 {0} else {if GBL.DSPSUBTYPE == 5599 {0} else {1}})
    prop seizeHwi :: (if ($1.client == "USER" && $1 == HWI_UNUSED) {self.error("Interrupt not mapped for selected timer.")} else {if ($1.client == "USER" && $1.function != @HWI_unused) {self.error("Interrupt mapped to selected timer is already in use.")} else {if ($1.client == "CSL") {self.error("Interrupt mapped to selected timer is already in use by CSL.")} else {$1.function = @CLK_F_isr, $1.client = "CLK", $1.iEventId = $1.iSource.iIntrSelectNum, $1.iUseDispatcher = (if CLK.HOOKFXN == @HWI_F_dispatch {1} else {0}), $1.iArg = (if $1.iUseDispatcher == 1 {@CLK_A_TABBEG} else {0}), HWI.gDirty = 1, "ok"}}})
    prop releaseHwi :: ($1.function = @HWI_unused, $1.client = "USER", $1.iUseDispatcher = 0, $1.iArg = 0, HWI.gDirty = 1, "ok")
    prop seizeTimer :: (if ($1 == "Timer 0") {self.WHICHTIMER = "Timer 0", self.WHICHHWI = Timer_0.iHwi, self.REGS = if (GBL.DSPSUBTYPE == 5599) {0x620} else {0x01000}, self.TIMERNUM = 0, self.TIMERIMR = 0x0, self.TIMERIFR = 0x1, self.INTBIT = 4, self.TIMERIMRMASK = self.WHICHHWI.Ier0Mask, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 1") {self.WHICHTIMER = "Timer 1", self.WHICHHWI = Timer_1.iHwi, self.REGS = if (GBL.DSPSUBTYPE == 5599) {0x640} else {0x2400}, self.TIMERNUM = 1, self.TIMERIMR = 0x45, self.TIMERIFR = 0x46, self.INTBIT = 6, self.TIMERIMRMASK = self.WHICHHWI.Ier1Mask, self.IMR0TINTMASK = 0x0, self.IMR1TINTMASK = self.WHICHHWI.Ier1Mask, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 2") {self.WHICHTIMER = "Timer 2", self.WHICHHWI = Timer_2.iHwi, self.REGS = 0x4000, self.TIMERNUM = 2, self.TIMERIMR = 0x0, self.TIMERIFR = 0x1, self.INTBIT = 11, self.TIMERIMRMASK = self.WHICHHWI.Ier0Mask, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, self.setMicroseconds(self.MICROSECONDS)} }}, "ok")
    prop setMicroseconds :: ($a = if FIXTDDR == 1 {self.TDDR} else {0xffffffff}, $b = 0xffffffff, $c = (float($a) + 1.0) * ((float($b) + self.adjustPrd) / (GBL.MIPS / 8)), if ($1 < $c && $1 > 0.1) {if (self.FIXTDDR == 0) {self.TDDR = int((1.0 * $1 * GBL.MIPS / 8) / (float($b) + self.adjustPrd))} , self.PRD = int((1.0 * $1 * GBL.MIPS) / (8 * (self.TDDR + 1.0))) - self.adjustPrd, self.MICROSECONDS = ((float((self.PRD)) + CLK.adjustPrd) * ((self.TDDR) + 1.0) * 8 / GBL.MIPS), if (self.CALLBACKOBJ != nil) {self.CALLBACKOBJ.call()} , "ok"} else {self.error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")})
    prop call :: ($a = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 8 / GBL.MIPS), $b = CLK.MICROSECONDS, $e = "ok", if (($e = self.setMicroseconds(CLK.MICROSECONDS)) == "ok") {if (CLK.gGBLChain != nil) {$e = CLK.gGBLChain.call()} , if ($e != "ok") {self.setMicroseconds($b), self.error($e)} else {"ok"}} else {$e})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gGBLChain :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global WHICHHWI :: HWI_INT14 { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop Label :: "CPU Interrupt"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global INTBIT :: = self.WHICHHWI.iIntrEnableMask
    global WHICHTIMER :: "Timer 0" { 
        prop Label :: "Timer Selection"
        prop JSName :: "TIMERSELECT"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1,Timer 2"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (self.WHICHTIMER != $1) {if (self.USETIMER == 0) {$e = "ok"} else {if (self.WHICHHIRESTIMER == $1) {$e = self.error("Must choose a timer different from the high resolution timer")} else {if ($1 == "Timer 0") {$a = Timer_0.iHwi} else {if ($1 == "Timer 1") {$a = Timer_1.iHwi} else {$a = Timer_2.iHwi}}, $e = self.seizeHwi($a)}}, if ($e == "ok") {self.releaseHwi(self.WHICHHWI), if ($1 == "Timer 0") {self.TIMERNUM = 0, self.WHICHHWI = Timer_0.iHwi} else {if ($1 == "Timer 1") {self.TIMERNUM = 1, self.WHICHHWI = Timer_1.iHwi} else {self.TIMERNUM = 2, self.WHICHHWI = Timer_2.iHwi}}, self.WHICHTIMER = $1, self.HOOKFXN = if self.gNumOf > 0 {@HWI_F_dispatch} else {(if GBL.CALLMODEL == "far" {@CLK_F_frete} else {@CLK_F_rete})}, self.seizeHwi(self.WHICHHWI)} , $e} )
    }
    global REGS :: = if self.WHICHTIMER == "Timer 0" {self.TIMER0BASE} else {if self.WHICHTIMER == "Timer 1" {self.TIMER1BASE} else {self.TIMER2BASE}} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: 1
    }
    global TIMER0BASE :: 26476544 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visbile :: 0
        prop JSName :: "TIMER0BASE"
        prop NoGen :: 1
    }
    global TIMER1BASE :: 26738688 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visbile :: 0
        prop JSName :: "TIMER1BASE"
        prop NoGen :: 1
    }
    global TIMER2BASE :: 28049408 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visbile :: 0
        prop JSName :: "TIMER2BASE"
        prop NoGen :: 1
    }
    global TIMERNUM :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop NoGen :: 0
    }
    global USETIMER :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable CLK Manager"
        prop JSName :: "ENABLECLK"
        prop Visible :: 1
        prop Writable :: if self.gNumOf > 0 {0} else {1}
        prop NoGen :: 0
        prop Set :: (if ($1 == 1 && self.USETIMER == 0) {if (($e = self.seizeHwi(self.WHICHHWI)) == "ok") {self.USETIMER = 1, self.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}, self.HOOKFXN = if GBL.CALLMODEL == "far" {@CLK_F_frete} else {@CLK_F_rete}, self.seizeHwi(self.WHICHHWI), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, GlobalStatus.gDirty = 1, self.error("Current stack size inadequate to enable CLK")} else {if (GBL.ENABLEINST == 1) {IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE} , $e}} else {$e}} else {if ($1 == 0 && self.USETIMER == 1) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, if (GBL.ENABLEINST == 1) {IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0} , "ok"} else {"ok"}})
    }
    global HIRES :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use high resolution time for internal timings"
        prop JSName :: "HIRESTIME"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (CLK.USETIMER) {CLK.HIRES = $1, if (CLK.USETIMER) {CLK.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}} , "ok"} else {self.error("CLK Manager must be enabled in order to get high resolution timings.")})
    }
    global INSTRPERCLK :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MICROSECONDS :: 10.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "Microseconds/Int"
        prop JSName :: "MICROSECONDS"
        prop Set :: (self.setMicroseconds($1))
        prop Visible :: 1
        prop Writable :: if ((CLK.PROGTIMREGS != 0) | (self.USETIMER == 0)) {0} else {1}
        prop NoGen :: 1
    }
    global MICROSECS :: = int(round(self.MICROSECONDS)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PROGTIMREGS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Directly configure on-chip timer registers"
        prop JSName :: "CONFIGURETIMER"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global FIXTDDR :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Fix TDDR"
        prop JSName :: "FIXTDDR"
        prop Visible :: (GBL.DSPTYPE != 62) && (GBL.DSPSUBTYPE != 2420) && (GBL.DSPSUBTYPE != 5599)
        prop Writable :: CLK.PROGTIMREGS && (GBL.DSPTYPE != 62) && (GBL.DSPSUBTYPE != 2420) && (GBL.DSPSUBTYPE != 5599)
        prop NoGen :: 1
    }
    global TDDR :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: if GBL.DSPSUBTYPE == 5561 {"TDDR Register (PREMD=0)"} else {"TDDR Register"}
        prop JSName :: "TCRTDDR"
        prop Set :: (if ((GBL.DSPSUBTYPE != 5502) && (GBL.DSPSUBTYPE != 5802) && (GBL.DSPTYPE != 62) && (GBL.DSPSUBTYPE != 5599) && ($1 > 0xffffffff)) {self.error("The on-chip timer does not have enough range to support this value, maximum is 15.")} else {CLK.TDDR = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 8 / GBL.MIPS), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok"})
        prop Visible :: GBL.DSPTYPE != 62
        prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
        prop NoGen :: 0
    }
    global TDDRHIGH :: = ((self.TDDR & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRD :: 900 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: if (GBL.CLKTYPE == 700) {"Compare0 Register"} else {"PRD Register"}
        prop JSName :: "PRD"
        prop Set :: (CLK.PRD = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 8 / GBL.MIPS), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok")
        prop Visible :: 1
        prop Writable :: if ((self.PROGTIMREGS) && (self.USETIMER)) {1} else {0}
        prop NoGen :: 0
    }
    global PRDHIGH :: = ((self.PRD & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global COUNTSPMS :: = int(round(GBL.MIPS * 1000.0 / (CLK.TDDR + 1) / 8)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
    }
    global COUNTSPMSHIGH :: = ((self.COUNTSPMS & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global INSTRUCTIONS :: = (1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 8) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.0f"
        prop Label :: "Instructions/Int"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TIMEFXN :: @CLK_F_getshtime { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HOOKFXN :: @HWI_F_dispatch { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CLKFXN :: = if (CLK.PRD == 0xffffffff) || (CLK.WHICHHIRESTIMER != "None") {@CLK_F_getfhtime} else {@CLK_F_getshtime} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: PRD { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALDIV :: = if GBL.DSPSUBTYPE == 2420 {self.HTIMEDIV} else {1} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CALMULT :: = if GBL.DSPSUBTYPE == 2420 {self.HTIMEMULT} else {if GBL.DSPSUBTYPE == 1510 {self.PRDMULTFACTOR * 8} else {8}} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEDIV :: = if GBL.DSPSUBTYPE == 2420 {self.setHtimeParams()} else {1} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEMULT :: = if GBL.DSPSUBTYPE == 1510 {self.PRDMULTFACTOR * 8} else {if GBL.DSPSUBTYPE == 2420 {self.setHtimeParams()} else {if GBL.DSPSUBTYPE == 5502 {8} else {if GBL.DSPSUBTYPE == 6499 {1} else {((self.TDDR + 1) * 8)}}}} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEDIV :: = if GBL.DSPSUBTYPE == 2420 {if self.INPUTCLK == 0.032 {self.setLtimeParams()} else {self.HTIMEDIV}} else {1} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEMULT :: = if GBL.DSPSUBTYPE == 1510 {(self.PRDMULTFACTOR * self.PRD * 8)} else {if GBL.DSPSUBTYPE == 2420 {if self.INPUTCLK == 0.032 {self.setLtimeParams()} else {(self.HTIMEMULT * self.PRD)}} else {((self.TDDR + 1) * (self.PRD + self.adjustPrd) * (8))}} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEPERLTIME :: = if GBL.DSPSUBTYPE == 5502 {int(round(GBL.MIPS * self.MICROSECONDS / 8))} else {if GBL.DSPSUBTYPE == 2420 {int(round(self.HTIMECLK * self.MICROSECONDS / 8))} else {if GBL.DSPSUBTYPE == 6499 {int(round(GBL.MIPS * self.MICROSECONDS))} else {(self.PRD + CLK.adjustPrd)}}} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global WHICHHIRESTIMER :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Timer 0,Timer 1,Timer 2"
        prop Label :: "Timer to use for high resolution timings"
        prop JSName :: "WHICHHIRESTIMER"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if ($1 == self.WHICHTIMER) {$e = self.error("Must choose a timer different from the system tick timer")} else {self.WHICHHIRESTIMER = $1, $e = "ok"}, $e)
    }
    global HIRESREGS :: = if self.WHICHHIRESTIMER != "None" {(if self.WHICHHIRESTIMER == "Timer 0" {self.TIMER0BASE} else {if self.WHICHHIRESTIMER == "Timer 1" {self.TIMER1BASE} else {self.TIMER2BASE}})} else {(self.REGS)} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (210)
    prop GlobalHelpTopic :: (110)
    prop InstancePropertyPage :: ("{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: ("%g ticks")
    prop STSGetSumFmt :: (PRD.STSGetMaxFmt())
    prop STSGetAvgFmt :: ("%.2f ticks")
    prop GetPeriod :: self.period
    prop IsOneShot :: if self.mode == "one-shot" {1} else {0}
    prop objectSize :: (if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (10 * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (9 * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (12 * 4)} , if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (12 * 4)} , if (GBL.DSPTYPE == 62) {$a = (8 * 4)} , $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {\n%8t %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s%5s\0, name, objSize, memSeg, linkString, pageString")
    prop GenLinkEpilogue :: ("%0t}\n\0")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {(if PRD.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if PRD.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if PRD.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {if GBL.DSPTYPE == 28 {" PAGE 1"} else {" PAGE 1"}}}
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {self.objectSize() * 2} else {self.objectSize()}
    prop dataSize :: (self.objectSize() * PRD.gNumOf)
    prop localInit :: (if (CLK.CALLBACKOBJ != nil) {self.error("PRD initialization failure")} , CLK.CALLBACKOBJ = PRD, if (PRD.USECLK && PRD_clock.iIsUsed == 0) {PRD_clock.Create("PRD")} , if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} else {PRD_clock.function = @PRD_F_tick}} )
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error(" System Stack Size too small")} else {self.myCreate("can")})
    prop localCreate :: (STS.gNumEmbed += 1, if (($a = self.myCreate("do")) == "ok") {if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {PRD_clock.function = @PRD_F_tick} } } , $a)
    prop localCanDelete :: (self.myDelete("can"))
    prop localDelete :: (STS.gNumEmbed -= 1, if (($a = self.myDelete("do")) == "ok") {if (self.gNumOf == 1) {if (PRD_clock.iIsUsed == 1) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} } } , $a)
    prop maxObjs :: (32767)
    prop myCreate :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (PRD_swi.iIsUsed) {"ok"} else {if (SWI.CanCreate() == "ok") {if ($1 == "do") {if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {PRD_swi.pri = 1} , PRD_swi.Create("PRD")} else {"ok"}} else {self.error("Can't create an SWI for PRD (try deleting a SWI)")}})
    prop myDelete :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (self.gNumOf == 1) {if ($1 == "do") {PRD_swi.Delete("PRD")} else {"ok"}} else {"ok"})
    prop call :: (if (CLK.USETIMER != 0) {PRD.MICROSECONDS = CLK.MICROSECONDS} , PRD.CALLBACKOBJ.call())
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"prd.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PRD_Obj %0r;\n\0"} else {"extern PRD_Obj %0r;\n\0"})
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop DEFAULT_THOOKFXN :: @_KNL_tick
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USECLK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use CLK Manager to drive PRD"
        prop JSName :: "USECLK"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 1 && self.USECLK == 0) {if (CLK.USETIMER == 0) {self.error("In order to drive periodic functions, the CLK Manager must be enabled")} else {self.USECLK = 1, self.MICROSECONDS = CLK.MICROSECONDS, CLK.CALLBACKOBJ = PRD, PRD_clock.Create("PRD"), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD"), self.error("Current Stack size inadequate to enable this option")} else {"ok"}}} else {if ($1 == 0 && self.USECLK == 1) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD")} , "ok"})
        prop NoGen :: 1
    }
    global MICROSECONDS :: 10.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Label :: "Microseconds/Tick"
        prop JSName :: "MICROSECONDS"
        prop Visible :: 1
        prop Writable :: self.USECLK == 0
        prop NoGen :: 1
    }
    global SCALAR :: = ($d = 2, $f = 0, while ($d <= 0x4000 && $f == 0) {scan ($i; PRD) {if ((($i.period / $d) * $d != $i.period)) || ($i.mode == "one-shot") {$f = 1} }, if ($f == 0) {$d = 2 * $d} }, $d / 2) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global THOOKFXN :: @_KNL_tick { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "System Tick Hook Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALLBACKOBJ :: STS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst period :: 0x7fff { 
        prop Label :: "period (ticks)"
        prop JSName :: "period"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if (($1 > 0) && ($1 < 0x8000)) {self.period = $1, self.gDirty = 1, "ok"} else {self.error("Periodic function periods must be greater than 0 and less than 0x8000")})
    }
    inst mode :: "continuous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "continuous,one-shot"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst milliseconds :: = ((self.period * PRD.MICROSECONDS) / 1000.0) { 
        prop Label :: "period (ms)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
    inst filter :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: "%g ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: "%g ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: "%.2f ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst unittype :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "unittype"
        prop NoGen :: 0
    }
}

object PRD_swi :: SWI {
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted when all PRD objects are deleted"
    param function :: @PRD_F_swi
    param pri :: 1
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 0
    param filter :: 2
    param maxformat :: "%g inst"
    param sumformat :: "%g inst"
    param avgformat :: "%.2f inst"
    param filtmaxmult :: 1
    param filtsummult :: 1
    param unittype :: 0
}

object PRD_clock :: CLK {
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    param function :: @PRD_F_tick
    param Order :: 0
    param iPri :: 0
}

type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: self.USERTDX
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (113)
    prop InstanceHelpTopic :: (213)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop AllocType :: (if self.USERTDX {"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"} else {""})
    prop _rtdxDataAllocDesc :: (" .%1L_data: {} \0, name")
    prop _rtdxTextAllocDesc :: (if (MEM.ENABLELOADSEG == 1) {if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {" .%1L_text: {} \0, name"} else {" .%1L_text: {} load > %2s, run \0, name, _loadRtdxTextMemSeg"}} else {" .%1L_text: {} \0, name"})
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop GenLinkPrologue :: (if self.USERTDX {"_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"} else {""})
    prop _interruptMask :: RTDX.MASK
    prop cGen :: 1
    prop noObjectAlias :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"rtdx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {if (self.iChannelMode == "output") {"extern far RTDX_outputChannel %0r;\n\0"} else {"extern far RTDX_inputChannel %0r;\n\0"}} else {if (self.iChannelMode == "output") {"extern RTDX_outputChannel %0r;\n\0"} else {"extern RTDX_inputChannel %0r;\n\0"}})
    prop cGenCInst :: (if (self.iChannelMode == "output") {"RTDX_CreateOutputChannel(%0r);\n\0"} else {"RTDX_CreateInputChannel(%0r);\n\0"})
    prop dataSize :: ($d = 0, if (self.USERTDX) {$d = RTDX.BUFMEMSIZE} else {$d = 0}, scan ($a; RTDX) {if ($a.iChannelMode == "output") {$d += 1} else {$d += 3}}, $d)
    prop localCanCreate :: ($e = "ok", if (RTDX.USERTDX != 1) {$e = self.error("RTDX manager not enabled")} , $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USERTDX :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Data Exchange (RTDX)"
        prop JSName :: "ENABLERTDX"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {if (HST.LNKTYPE == "RTDX") {self.error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX")} else {if (self.gNumOf > 0) {self.error("Cannot disable RTDX until all RTDX objects are deleted.")} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"}}} else {if ((GBL.DSPTYPE == 55) && (GBL.MEMORYMODEL == "HUGE")) {self.error("RTDX NOT enabled. Not supported for huge model")} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"}})
    }
    global USERTEXECUTION :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Execution Control"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RTDXTYPE :: "Simulator" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "JTAG,HSRTDX,Simulator"
        prop Label :: "RTDX Mode"
        prop JSName :: "MODE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (self.RTDXTYPE = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok")
    }
    global DATAMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "RTDX Data Segment (.rtdx_data)"
        prop JSName :: "RTDXDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global BUFMEMSIZE :: = (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "RTDX Buffer Size (MAUs)"
        prop JSName :: "BUFSIZE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (if (HST.RTDX == 0) {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, "ok"} else {if ($1 < (HST.MAXFRAMESET + 3) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {self.error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 3) * (MAUs per word)")} else {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, if (HST.LNKTYPE == "RTDX") {HST.MAXFRAMEALLOWED = (self.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"} else {"ok"}}})
    }
    global TEXTMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Label :: "RTDX Interrupt Mask"
        prop JSName :: "INTERRUPTMASK"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 1
        prop Set :: (self.MASK = $1, "ok")
    }
    global CALLBACKOBJ :: HWI { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iChannelMode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Channel Mode"
        prop JSName :: "channelMode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.iChannelMode = $1, "ok")
    }
}

type HST {
    isa ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "HWI"
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (104)
    prop InstanceHelpTopic :: (204)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop dataSize :: ($b = 0, scan ($i; HST) {if ($i.IsConfObj()) {$b += (12 + $i.framesize) * $i.numframes + PIP.OBJSIZE + self.objectSize()} }, $b)
    prop InstancePropertyPage :: ("{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}")
    prop localCreate :: (PIP.gNumEmbed += 1, if (self.gNumOf == 0) {(LNK_dataPump.Create("HST"))} , "ok")
    prop localDelete :: (PIP.gNumEmbed -= 1, $b = 0, scan ($i; HST) {if ($i != self) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } } }, self.MAXFRAMESET = $b, if (self.gNumOf == 1) {(LNK_dataPump.Delete("HST"))} , "ok")
    prop GenLinkPrologue :: (if (self.LNKTYPE == "RTDX") {"_LNK_dspFrameReadyMask = LNK_dspFrameReadyMask; \n_LNK_dspFrameRequestMask = LNK_dspFrameRequestMask; \n_LNK_readDone = LNK_readDone; \n_LNK_readFail = LNK_readFail; \n_LNK_readPend = LNK_readPend; \n_LNK_writeFail = LNK_writeFail;"} )
    prop AllocType :: ("2\0, _globalAllocDesc, _memSeg, _placement, 	      _dsmAllocDesc, _dsmMemSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop objectSize :: (if (GBL.DSPTYPE == 28) {$a = (10 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (8 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (8 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (6 * 4)} , if (GBL.DSPTYPE == 54 || GBL.DSPTYPE == 62) {$a = (5 * 4)} , $a)
    prop _dsmAllocDesc :: ("%8t .dsm: {}")
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: ("/* %0s buffer */\n.hst%2d: %3S\0, name, _objId, _alignString, _objAlign")
    prop _alignString :: if self.bufalign > 1 {"align = 0x%4x {}"} else {""}
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"hst.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far HST_Obj %0r;\n\0"} else {"extern HST_Obj %0r;\n\0"})
    prop modifiable :: ((if self.iDelUser == "USER" {1} else {0}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LNKTYPE :: "RTDX" { 
        prop Label :: "Host Link Type"
        prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 == "RTDX") {if (RTDX.USERTDX == 0) {if ((GBL.DSPTYPE == 55) && (GBL.MEMORYMODEL == "HUGE")) {self.error(" HOSTLINKTYPE cannot be RTDX for huge model")} else {self.error("RTDX module must be enabled before it can be used by HST")}} else {if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < self.MAXFRAMESET) {self.error("RTDX buffer size too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"}}}} else {if ($1 == "Shared Memory") {if ((self.DSMMEMSIZE / 4) < self.MAXFRAMESET) {self.error("Shared memory buffer too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"}}} else {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, "ok"}})
    }
    global RTDX :: = if self.LNKTYPE == "RTDX" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM :: = if self.LNKTYPE == "Shared Memory" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 :: = if self.LNKTYPE == "EVM54" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE :: = if self.LNKTYPE == "NONE" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET :: 64 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED :: 255 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
    }
    global DSMMEMSIZE :: = 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
        prop Set :: (if ($1 < HST.MAXFRAMESET * 4) {self.error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")} else {self.DSMMEMSIZE = $1, GlobalStatus.gDirty = 1, if (self.LNKTYPE == "Shared Memory") {self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {"ok"}})
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst mode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "mode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst bufalign :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("Alignment must be greater than or equal to 4")} else {if (($1 % 2) != 0) {self.error("Alignment must be a power of 2")} else {$i = $1, while ((($i % 2) == 0) && ($i != 2)) {$i = $i / 2}, if (($i % 2) != 0) {self.error("Alignment must be a power of 2")} else {self.bufalign = $1, "ok"}}})
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {if (($1 > self.MAXFRAMEALLOWED) && ((self.RTDX == 1) || (self.DSM == 1))) {if (self.RTDX == 1) {self.error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 3")} else {self.error("size (in words) is limited to: shared memory frame size (in MAUs)/4")}} else {self.framesize = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, GlobalStatus.gDirty = 1, "ok"}})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Channels must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst stsflg :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "statistics"
        prop JSName :: "statistics"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst lnk :: = if self.RTDX {"RTDX"} else {"NOTRTDX"} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "link type"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Make this channel available for a new DHL device"
        prop JSName :: "availableForDHL"
        prop Set :: (if (($1 == 0) && (self.iDHLAvailable == 1)) {DHL.gChannelsAvailable--} else {if (($1 == 1) && (self.iDHLAvailable == 0)) {DHL.gChannelsAvailable++} }, self.iDHLAvailable = $1, "ok")
        prop Writable :: self.modifiable()
        prop Visible :: 1
        prop NoGen :: 1
    }
    inst bufFrameAlign :: = self.bufalign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

object LNK_dataPump :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @LNK_F_dataPump
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_dispatcher :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @RTA_F_dispatch
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_fromHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "input"
    param bufseg :: IRAM
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 4
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

object RTA_toHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "output"
    param bufseg :: IRAM
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 64
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

type HWI {
    isa ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (205)
    prop GlobalHelpTopic :: (105)
    prop dataSize :: (0 * HWI.gNumOf)
    prop localCanCreate :: (self.error("New hardware interrupt objects cannot be created"))
    prop InstancePropertyPage :: ("{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}")
    prop DependsOn :: "GBL,OBJ,BUF,CLK,IDL,LCK,LOG,MBX,MEM,PIP,POOL,PRD,QUE,RTDX,SEM,STS,SYS"
    prop AllocType :: (if self.ZEROTAB {"1\0,   _stubsAllocDesc,        _memSeg,        _placement"} else {if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"2\0,       _stubsAllocDesc,        _memSeg,        _placement,
                        _vectAllocDesc,         _loadvecSeg,    _minplace"} else {"2\0,       _stubsAllocDesc,        _memSeg,        _placement,
                        _vectAllocDesc,         _vecSeg,        _minplace"}})
    prop _stubsAllocDesc :: (if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG)) {"%8t .%1L: {} load > %2s, run\0, name, _loadstubSeg"} else {"%8t .%1L: {} \0, name"})
    prop _vectAllocDesc :: (if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"%8t .%1L_vec: {%12t\n %1U_A_VECS = .;\n *(.hwi_vec)%8t\n } run > %2s align = 0x400, load \0, name, _vecSeg"} else {"%8t .%1L_vec: {%12t\n %1U_A_VECS = .;\n *(.hwi_vec)%8t\n } align = 0x400\0, name"})
    prop _placement :: (0x7fffffff / 2)
    prop _minplace :: 0
    prop GenLinkPrologue :: (if self.ZEROTAB {if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"SECTIONS {%4t\n .%1L_vec: {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }  load >  %2s, run = 0x0 %0t\n}\n\0 , name, _loadvecSeg"} else {"SECTIONS {%4t\n .%1L_vec: 0x0 {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }%0t\n}\n\0, name"}} else {if self.GENERATE_RESET_VEC {"SECTIONS {%4t\n .%1L_reset: %2x {}%0t\n}\n\0, name, .RESETVECTORADDR"} else {""}})
    prop GenLinkEpilogue :: ("%0t_HWI_CFGDISPATCHED = HWI_CFGDISPATCHED;\n\0")
    prop localInit :: (if (RTDX.CALLBACKOBJ != nil) {self.error("HWI initialization failure.")} , RTDX.CALLBACKOBJ = HWI)
    prop call :: (if (RTDX.USERTDX == 0) {HWI_RESERVED1.function = @HWI_unused, HWI_RESERVED1.iUseDispatcher = 0, if (HWI_INT9.iSource == JTAGRTDX9 && HWI_INT9.function == @_RTDX_Poll) {HWI_INT9.iSource = MCSP_0_Transmit, HWI_INT9.iReMappable = 1, HWI_INT9.function = @HWI_unused, HWI_INT9.iUseDispatcher = 0, HWI_INT9.iIntrMask = "self", HWI_INT9.IntrMask = 0x200, HWI_INT9.client = "USER"} , if (HWI_INT11.iSource == HSRTDX11 && HWI_INT11.function == @_HSRTDX_xmt) {HWI_INT11.iSource = MCSP_0_Receive, HWI_INT11.iReMappable = 1, HWI_INT11.function = @HWI_unused, HWI_INT11.iUseDispatcher = 0, HWI_INT11.iIntrMask = "self", HWI_INT11.IntrMask = 0x800, HWI_INT11.client = "USER"} , if (HWI_INT12.iSource == HSRTDX12 && HWI_INT12.function == @_HSRTDX_rec) {HWI_INT12.iSource = MCSP_1_Transmit, HWI_INT12.iReMappable = 1, HWI_INT12.function = @HWI_unused, HWI_INT12.iUseDispatcher = 0, HWI_INT12.iIntrMask = "self", HWI_INT12.IntrMask = 0x1000, HWI_INT12.client = "USER"} } else {HWI_RESERVED1.function = @_RTDX_Poll, HWI_RESERVED1.iUseDispatcher = 1, if (RTDX.RTDXTYPE == "HSRTDX") {if (HWI_INT9.iSource == JTAGRTDX9 && HWI_INT9.function == @_RTDX_Poll) {HWI_INT9.iSource = MCSP_0_Transmit, HWI_INT9.iReMappable = 1, HWI_INT9.function = @HWI_unused, HWI_INT9.iUseDispatcher = 0, HWI_INT9.iIntrMask = "self", HWI_INT9.IntrMask = 0x200, HWI_INT9.client = "USER"} , HWI_INT11.iSource = HSRTDX11, HWI_INT11.iReMappable = 0, HWI_INT11.function = @_HSRTDX_xmt, HWI_INT11.iUseDispatcher = 1, HWI_INT11.iIntrMask = "bitmask", HWI_INT11.IntrMask = 0x1808, HWI_INT11.client = "RTDX", HWI_INT12.iSource = HSRTDX12, HWI_INT12.iReMappable = 0, HWI_INT12.function = @_HSRTDX_rec, HWI_INT12.iUseDispatcher = 1, HWI_INT12.iIntrMask = "bitmask", HWI_INT12.IntrMask = 0x1808, HWI_INT12.client = "RTDX"} else {HWI_INT9.iSource = JTAGRTDX9, HWI_INT9.iReMappable = 0, HWI_INT9.function = @_RTDX_Poll, HWI_INT9.iUseDispatcher = 1, HWI_INT9.iIntrMask = "bitmask", HWI_INT9.IntrMask = 0x208, HWI_INT9.client = "RTDX", if (HWI_INT11.iSource == HSRTDX11 && HWI_INT11.function == @_HSRTDX_xmt) {HWI_INT11.iSource = MCSP_0_Receive, HWI_INT11.iReMappable = 1, HWI_INT11.function = @HWI_unused, HWI_INT11.iUseDispatcher = 0, HWI_INT11.iIntrMask = "self", HWI_INT11.IntrMask = 0x800, HWI_INT11.client = "USER"} , if (HWI_INT12.iSource == HSRTDX12 && HWI_INT12.function == @_HSRTDX_rec) {HWI_INT12.iSource = MCSP_1_Transmit, HWI_INT12.iReMappable = 1, HWI_INT12.function = @HWI_unused, HWI_INT12.iUseDispatcher = 0, HWI_INT12.iIntrMask = "self", HWI_INT12.IntrMask = 0x1000, HWI_INT12.client = "USER"} }})
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: ($b = 0, scan ($a; HWI) {if ($a.monitor != "Nothing") {$b = 1} }, if ($b == 1) {"*(.hwi)"} else {"/* no HWI stubs are necessary */"})
    prop name2addr :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "Stack Pointer", "Top of SW Stack", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "A15", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15"}) {if ($b == nil) {if ($a == $1) {$b = {0, 0, 0, @GBL_stackbeg, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}[$i]} , $i++} }, if ($b == nil) {$b = 0} , $b)
    prop name2type :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "Stack Pointer", "Top of SW Stack", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "A15", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15"}) {if ($b == nil) {if ($a == $1) {if ($i < 5) {$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]} } , $i++} }, if ($b == nil) {$b = "unsigned"} , $b)
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    prop HWIR0_DISP :: (if (HWI_RESERVED0.iUseDispatcher == 1) {0x4} else {0})
    prop HWIR1_DISP :: (if (HWI_RESERVED1.iUseDispatcher == 1) {0x8} else {0})
    prop HWI4_DISP :: (if (HWI_INT4.iUseDispatcher == 1) {0x10} else {0})
    prop HWI5_DISP :: (if (HWI_INT5.iUseDispatcher == 1) {0x20} else {0})
    prop HWI6_DISP :: (if (HWI_INT6.iUseDispatcher == 1) {0x40} else {0})
    prop HWI7_DISP :: (if (HWI_INT7.iUseDispatcher == 1) {0x80} else {0})
    prop HWI8_DISP :: (if (HWI_INT8.iUseDispatcher == 1) {0x100} else {0})
    prop HWI9_DISP :: (if (HWI_INT9.iUseDispatcher == 1) {0x200} else {0})
    prop HWI10_DISP :: (if (HWI_INT10.iUseDispatcher == 1) {0x400} else {0})
    prop HWI11_DISP :: (if (HWI_INT11.iUseDispatcher == 1) {0x800} else {0})
    prop HWI12_DISP :: (if (HWI_INT12.iUseDispatcher == 1) {0x1000} else {0})
    prop HWI13_DISP :: (if (HWI_INT13.iUseDispatcher == 1) {0x2000} else {0})
    prop HWI14_DISP :: (if (HWI_INT14.iUseDispatcher == 1) {0x4000} else {0})
    prop HWI15_DISP :: (if (HWI_INT15.iUseDispatcher == 1) {0x8000} else {0})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 65535 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 16 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STUBMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ZEROTAB :: = if 6400 == 6499 {0} else {self.VECMEMSEG.base == self.RESETVECTORADDR} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Writable :: 0
        prop Visible :: 0
    }
    global VECMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop MemberTest :: MEM.codeMember($1)
        prop Set :: (self.VECMEMSEG = $1, if ($1.base == 0) {self.GENERATE_RESET_VEC = 0} , "ok")
    }
    global GENERATE_RESET_VEC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate RESET vector"
        prop JSName :: "RESETVECTOR"
        prop Writable :: self.ZEROTAB == 0
        prop Visible :: 1
        prop NoGen :: 0
    }
    global RESETVECTORADDR :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "RESET vector address"
        prop JSName :: "RESETVECTORADDR"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Writable :: self.GENERATE_RESET_VEC
        prop Visible :: 1
        prop NoGen :: 1
    }
    global EXT4_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 4 Polarity"
        prop JSName :: "EXTPIN4POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT5_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 5 Polarity"
        prop JSName :: "EXTPIN5POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT6_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 6 Polarity"
        prop JSName :: "EXTPIN6POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT7_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 7 Polarity"
        prop JSName :: "EXTPIN7POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global POLARITYMASK :: = (if self.EXT4_POLARITY == "high-to-low" {1} else {0}) | (if self.EXT5_POLARITY == "high-to-low" {1} else {0}) << 1 | (if self.EXT6_POLARITY == "high-to-low" {1} else {0}) << 2 | (if self.EXT7_POLARITY == "high-to-low" {1} else {0}) << 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global INTRMULTLOW :: = (HWI_INT4.iEventId) | (HWI_INT5.iEventId << 5) | (HWI_INT6.iEventId << 10) | (HWI_INT7.iEventId << 16) | (HWI_INT8.iEventId << 21) | (HWI_INT9.iEventId << 26) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global INTRMULTHIGH :: = (HWI_INT10.iEventId) | (HWI_INT11.iEventId << 5) | (HWI_INT12.iEventId << 10) | (HWI_INT13.iEventId << 16) | (HWI_INT14.iEventId << 21) | (HWI_INT15.iEventId << 26) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global CFGDISPATCHED :: = (self.HWIR0_DISP | self.HWIR1_DISP | self.HWI4_DISP | self.HWI5_DISP | self.HWI6_DISP | self.HWI7_DISP | self.HWI8_DISP | self.HWI9_DISP | self.HWI10_DISP | self.HWI11_DISP | self.HWI12_DISP | self.HWI13_DISP | self.HWI14_DISP | self.HWI15_DISP) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "dispatched mask"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visible :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iSource :: Reset { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: ISRC
        prop MemberTest :: 1
        prop Label :: "interrupt source"
        prop JSName :: "interruptSource"
        prop Visible :: if (GBL.CLKTYPE == 700) {0} else {if (GBL.DSPSUBTYPE == 6499) {0} else {1}}
        prop Writable :: if (GBL.CLKTYPE == 700) {0} else {self.iReMappable}
        prop NoGen :: 1
        prop Set :: ($a = $1, if ($a == Reset) {self.error("The Reset interrupt source cannot be remapped")} else {if ($a == Non_Maskable) {self.error("The Non-Maskable interrupt source cannot be remapped")} else {if ($a == Reserved) {self.error("The Reserved interrupt source cannot be remapped")} else {if (CLK.WHICHHWI == self && $a != self.iSource && CLK.USETIMER) {self.error("This interrupt is in use by CLK, settings may be changed in the CLK Manager")} else {if ($a == CLK.WHICHHWI.iSource && CLK.USETIMER == 1) {self.error("Interrupt source is in use by CLK, settings may be changed in the CLK Manager.")} else {$a.iHwi = self, self.iSource.iHwi = HWI_UNUSED, self.iSource = $1, self.iEventId = self.iSource.iIntrSelectNum, "ok"}}}}})
    }
    inst iEventId :: = self.iSource.iIntrSelectNum { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "interrupt selection number"
        prop JSName :: "interruptSelectNumber"
        prop Style :: 0x02
        prop Visible :: if (GBL.CLKTYPE == 700) {0} else {1}
        prop Writable :: if (GBL.CLKTYPE == 700) {0} else {self.iReMappable}
        prop NoGen :: 1
    }
    inst iReMappable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIntrEnableMask :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @HWI_unused { 
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if ((self.function == @RESERVED) || (self.client != "USER")) {0} else {1}
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (self.function = $1, GlobalStatus.gDirty = 1, "ok")
    }
    inst iSTSObj :: HWI_RESETSTS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst monitor :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value,Stack Pointer,Top of SW Stack,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((self.function != @HWI_unused && self.function != @RESERVED) && (self.iId != 0))
        prop NoGen :: 0
        prop Set :: (if ($1 != self.monitor) {$e = "ok", if ($1 == "Nothing") {if (($e = self.iSTSObj.Delete("HWI")) == "ok") {self.monitor = "Nothing", self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)} } else {if (self.iSTSObj.iIsUsed || ($e = self.iSTSObj.Create("HWI")) == "ok") {self.monitor = $1, if (self.monitor == "Data Value") {self.addr = self.saveAddr, self.dataType = self.saveType} else {self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)}} else {self.monitor = "Nothing"}}, $e} else {"ok"})
    }
    inst saveAddr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst saveType :: "signed" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst addr :: 0 { 
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Data Value" {1} else {0})
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Set :: (self.addr = $1, self.saveAddr = $1, "ok")
    }
    inst dataType :: "signed" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (if (self.monitor != "Nothing") {self.dataType = $1, self.saveType = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst operation :: "STS_add(*addr)" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (if (self.monitor != "Nothing") {self.operation = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst client :: "USER" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iUseDispatcher :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: if (self.client == "USER") {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if (($1 == 1) && (self == HWI_NMI)) {self.error("HWI dispatcher can't be used for  NMI")} else {self.iUseDispatcher = $1, "ok"})
    }
    inst iArg :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.client == "USER")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (self.iArg = $1, "ok")
    }
    inst iIntrMask :: "self" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask"
        prop JSName :: "interruptMask"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "all") {self.IntrMask = 0xffff} else {if ($1 == "self") {self.IntrMask = 1 << self.iId} else {if ($1 == "none") {self.IntrMask = 0} }}, self.iIntrMask = $1, "ok")
    }
    inst IntrMask :: (1 << self.iId) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask"
        prop JSName :: "interruptBitMask"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iIntrMask == "bitmask")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 > 0xffff) {self.error("Invalid Number")} else {self.IntrMask = $1, "ok"})
    }
    inst iCacheControl :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't modify cache control"
        prop JSName :: "cacheControl"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == 1) {self.iCCBitMask = 0x1} else {self.iCCBitMask = (self.iPCCBitMask | self.iDCCBitMask)}, self.iCacheControl = $1, "ok")
    }
    inst iPCCMask :: (if (GBL.DSPSUBTYPE == 6200 || GBL.DSPSUBTYPE == 6700) {"mapped"} else {"cache enable"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Program Cache Control Mask"
        prop JSName :: "progCacheMask"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iCacheControl == 0)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6400) && $1 != "cache enable") {self.error("unsupported cache mode for 6x1x/64x device (cache enable must be selected)")} else {if ($1 == "mapped") {self.iPCCBitMask = 0x0000} else {if ($1 == "cache enable") {self.iPCCBitMask = 0x0040} else {if ($1 == "cache freeze") {self.iPCCBitMask = 0x0060} else {self.iPCCBitMask = 0x0080}}}, self.iPCCMask = $1, self.iCCBitMask = self.iPCCBitMask | self.iDCCBitMask, "ok"})
    }
    inst iPCCBitMask :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDCCMask :: (if (GBL.DSPSUBTYPE == 6200 || GBL.DSPSUBTYPE == 6700) {"mapped"} else {"cache enable"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Data Cache Control Mask"
        prop JSName :: "dataCacheMask"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iCacheControl == 0)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6400) && $1 != "cache enable") {self.error("unsupported cache mode for 6x1x/64x device (cache enable must be selected)")} else {if ($1 == "mapped") {self.iDCCBitMask = 0x0000} else {if ($1 == "cache enable") {self.iDCCBitMask = 0x0008} else {if ($1 == "cache freeze") {self.iDCCBitMask = 0x000C} else {self.iDCCBitMask = 0x0010}}}, self.iDCCMask = $1, self.iCCBitMask = self.iPCCBitMask | self.iDCCBitMask, "ok"})
    }
    inst iDCCBitMask :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCCBitMask :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iLoadTrack :: 0 { 
        prop Label :: "Support CPU load tracking"
        prop JSName :: "loadTrack"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reset
    param iReMappable :: 0
    param iIntrEnableMask :: 1
    param function :: @_c_int00
    param iSTSObj :: HWI_RESET_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 1
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Non_Maskable
    param iReMappable :: 0
    param iIntrEnableMask :: 2
    param function :: @HWI_unused
    param iSTSObj :: HWI_NMI_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 2
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_RESERVED0_STS :: STS {
    param iComment :: "This STS object is being used by a HWI object and cannot be deleted"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESERVED0 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iIsUsed :: 1
    param iId :: 2
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reserved
    param iReMappable :: 0
    param iIntrEnableMask :: 4
    param function :: @RESERVED
    param iSTSObj :: HWI_RESERVED0_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 4
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_RESERVED1_STS :: STS {
    param iComment :: "This STS object is being used by a HWI object and cannot be deleted"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESERVED1 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iIsUsed :: 1
    param iId :: 3
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reserved
    param iReMappable :: 0
    param iIntrEnableMask :: 8
    param function :: @_RTDX_Poll
    param iSTSObj :: HWI_RESERVED1_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 8
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iIsUsed :: 1
    param iId :: 4
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_4
    param iReMappable :: 1
    param iIntrEnableMask :: 16
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT4_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 16
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iIsUsed :: 1
    param iId :: 5
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_5
    param iReMappable :: 1
    param iIntrEnableMask :: 32
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT5_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 32
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT6_STS :: STS {
    param iComment :: "provides statistics for the INT6 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iIsUsed :: 1
    param iId :: 6
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_6
    param iReMappable :: 1
    param iIntrEnableMask :: 64
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT6_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 64
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iIsUsed :: 1
    param iId :: 7
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: External_Pin_7
    param iReMappable :: 1
    param iIntrEnableMask :: 128
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT7_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 128
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iIsUsed :: 1
    param iId :: 8
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: EDMA_Controller
    param iReMappable :: 1
    param iIntrEnableMask :: 256
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT8_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 256
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT9 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT9 :: HWI {
    param iComment :: "defines the INT9 Interrupt"
    param iIsUsed :: 1
    param iId :: 9
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: JTAGRTDX9
    param iReMappable :: 0
    param iIntrEnableMask :: 520
    param function :: @_RTDX_Poll
    param iSTSObj :: HWI_INT9_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIntrMask :: "bitmask"
    param IntrMask :: 520
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iIsUsed :: 1
    param iId :: 10
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Timer_2
    param iReMappable :: 1
    param iIntrEnableMask :: 1024
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT10_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 1024
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iIsUsed :: 1
    param iId :: 11
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: MCSP_0_Receive
    param iReMappable :: 1
    param iIntrEnableMask :: 2048
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT11_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 2048
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iIsUsed :: 1
    param iId :: 12
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: MCSP_1_Transmit
    param iReMappable :: 1
    param iIntrEnableMask :: 4096
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT12_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 4096
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iIsUsed :: 1
    param iId :: 13
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Host_Port_Host_to_DSP
    param iReMappable :: 1
    param iIntrEnableMask :: 8192
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT13_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 8192
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param iIsUsed :: 1
    param iId :: 14
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Timer_0
    param iEventId :: 1
    param iReMappable :: 1
    param iIntrEnableMask :: 16384
    param function :: @CLK_F_isr
    param iSTSObj :: HWI_INT14_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "CLK"
    param iUseDispatcher :: 1
    param iArg :: @CLK_A_TABBEG
    param iIntrMask :: "self"
    param IntrMask :: 16384
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param iIsUsed :: 1
    param iId :: 15
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Timer_1
    param iEventId :: 2
    param iReMappable :: 1
    param iIntrEnableMask :: 32768
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT15_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 32768
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_UNUSED :: HWI {
    param iComment :: "a dummy DSP interrupt for unused sources"
    param iIsUsed :: 0
    param iId :: 16
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reset
    param iReMappable :: 1
    param iIntrEnableMask :: 0
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT15_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 65536
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

type SWI {
    isa ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop DependsOn :: "HWI,SIO,HST,MSGQ"
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (211)
    prop GlobalHelpTopic :: (111)
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop uType :: (if (self.HighTimeBased()) {$a = 0} else {if (self.LowTimeBased()) {$a = 1} else {$a = 2}}, $a)
    prop STSGetMaxFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (SWI.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMaxMult :: ($a = 1)
    prop STSFilterSumMult :: (SWI.STSFilterMaxMult($1))
    prop GetPriority :: (self.pri)
    prop objectSize :: (if ((GBL.DSPTYPE == 54 && GBL.FARMODE == 0) || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {$a = (12 * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (14 * 4)} , if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (20 * 4)} , if (GBL.DSPTYPE == 62) {$a = (11 * 4)} , $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {%8t\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;%4t\n} > %3s%5s\0, name, objSize, memSeg, linkString, pageString")
    prop GenLinkEpilogue :: ("%0t}\n\0")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {(if SWI.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if SWI.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if SWI.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop memSeg :: SWI.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop maxObjs :: (32767)
    prop dataSize :: (self.objectSize() * SWI.gNumOf)
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {"ok"})
    prop localCreate :: (STS.gNumEmbed += 1, SWI.EXECFXN = @SWI_F_exec, SWI.RUNFXN = @SWI_F_run, "ok")
    prop localDelete :: (STS.gNumEmbed -= 1, if (self.gNumOf == 1) {SWI.EXECFXN = @FXN_F_nop, SWI.RUNFXN = @FXN_F_nop} , "ok")
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: ("{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"swi.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SWI_Obj %0r;\n\0"} else {"extern SWI_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global EHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXECFXN :: @SWI_F_exec { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RUNFXN :: @SWI_F_run { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive body"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst priority :: = (self.pri + 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
        prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst pri :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
        prop Label :: "priority"
        prop JSName :: "priority"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: ($a = self.pri, self.pri = $1, if (self == KNL_swi) {if ($1 != 0) {self.pri = $a, self.error("KNL_swi must remain at Priority 0.")} else {"ok"}} else {if ($1 == 0 && KNL_swi.iIsUsed == 1) {self.pri = $a, self.error("Priority 0 reserved for KNL_swi only.")} else {GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.pri = $a, self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {if ($1 > 14) {self.pri = $a, self.error("SWI can only support 15 priority levels.")} else {"ok"}}}})
    }
    inst mailbox :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mailbox"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst dorta :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
    inst filter :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: self.STSGetMaxFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: self.STSGetSumFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: self.STSGetAvgFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst filtmaxmult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtmaxmult"
        prop NoGen :: 0
    }
    inst filtsummult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtsummult"
        prop NoGen :: 0
    }
    inst unittype :: self.uType() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "unittype"
        prop NoGen :: 0
    }
}

type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: self.USETSK
    prop IsContainedIn :: SCH
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (314)
    prop InstanceHelpTopic :: (414)
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A65-B1A8-11d0-9885-0020AFEE33C6}")
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop objectSize :: (if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (27 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (44 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (44 * 4)} , if (GBL.DSPTYPE == 28) {$a = (40 * 4)} , if (GBL.DSPTYPE == 62 || (GBL.DSPTYPE == 54 && GBL.FARMODE == 0)) {$a = (24 * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (25 * 4)} , $a)
    prop GenLinkPrologue :: (if (self.USETSK != 0) {"SECTIONS {%4t\n.%1L: {%8t\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;%4t\n} > %3s%5s\0, name, objSize, _bssmemSeg, linkString, pageString"} else {"_KNL_swi = 0;"})
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {(if TSK.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if TSK.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if TSK.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop GenLinkEpilogue :: (if (self.USETSK != 0) {"%0t}\n\0"} else {""})
    prop _objAllocDesc :: ("%8t .TSK$obj: {}")
    prop _bssmemSeg :: self.OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG
    prop AllocInst :: (if self.iAUTOSTK {"1\0, _instStackDesc, _instStackSeg, _placement"} else {"0\0"})
    prop _instStackDesc :: (if (GBL.DSPTYPE == 40) {"%8t .%0s$stk: {%12t\n %0s$stack = .;\n . += %1d;%8t\n }\0, _instStackSize"} else {"%8t .%0s$stk: {%12t\n *(.%0s$stk)%8t\n }\0"})
    prop _self :: self
    prop _instStackSize :: self.iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: self.iSTKSEG
    prop _placement :: (0x7fffffff / 2)
    prop localInit :: (KNL_swi.Create("SWI"), if (self.STACKSEG.iAllocHeap == 1) {self.STACKSEG.iReqHeapCount++, "ok"} else {self.error("TSK default stack segment must be a memory segment with a heap")})
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop uType :: (if (self.HighTimeBased()) {$a = 0} else {if (self.LowTimeBased()) {$a = 1} else {$a = 2}}, $a)
    prop STSGetMaxFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (TSK.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMaxMult :: ($a = 1)
    prop STSFilterSumMult :: (TSK.STSFilterMaxMult($1))
    prop localCreate :: (STS.gNumEmbed += 1, "ok")
    prop localCanCreate :: ($e = "ok", if (TSK.USETSK != 1) {$e = self.error("TSK manager not enabled")} , $e)
    prop localDelete :: (STS.gNumEmbed -= 1, "ok")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"tsk.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far TSK_Obj %0r;\n\0"} else {"extern TSK_Obj %0r;\n\0"})
    prop NOPFXN :: @FXN_F_nop
    prop _objId :: self.iId
    prop objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop dataSize :: ($d = 0, scan ($i; TSK) {$d += ($i.iSTKSZ + self.objectSize() * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))}, $d)
    prop minStackSize :: ($a = self.STACKSIZE, scan ($i; TSK) {if ($i.STACKSIZE < $a) {$a = $i.STACKSIZE} }, $a)
    prop maxObjs :: (32767)
    prop GetPriority :: (self.iPRI)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USETSK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable TSK Manager"
        prop JSName :: "ENABLETSK"
        prop Visible :: 1
        prop Writable :: if GBL.DSPSUBTYPE == 0x55DA200 {0} else {1}
        prop NoGen :: 1
        prop Set :: (if ($1 == 0) {if (self.gNumOf > 1) {self.error("Cannot disable TSK until all TSK objects are deleted.")} else {self.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, TSK.OBJMEMSEG = MEM_NULL, TSK_idle.iSTKSEG = MEM_NULL, TSK_idle.Delete("TSK"), KNL_swi.Delete("TSK"), PRD.THOOKFXN = self.NOPFXN, if (PRD.gNumOf == 0) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @FXN_F_nop} } , self.USETSK = $1, "ok"}} else {$e = "ok", GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {$e = self.error("Current stack size inadequate to enable TSK"), break} , scan ($a; SWI) {if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {$e = self.error("Cannot enable TSK when there are SWI objects at Priority 0."), break} }, if ($e == "ok") {TSK.STACKSEG = MEM_NULL, scan ($b; MEM) {if ($b.iAllocHeap && $b != MEM_NULL) {TSK.STACKSEG = $b, break} }, self.STACKSEG.iReqHeapCount++, self.USETSK = $1, TSK.OBJMEMSEG = SWI.OBJMEMSEG, TSK_idle.iSTKSEG = self.OBJMEMSEG, TSK_idle.Create("TSK"), KNL_swi.Create("TSK"), PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN, if (TSK.TSKTICK == "PRD") {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @PRD_F_tick} } , if (MEM.NOHEAPS) {self.STACKSEG.iReqHeapCount++} , $e} else {$e}})
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "OBJMEMSEG"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: if GBL.DSPTYPE == 54 {0x01} else {0x02}
        prop Label :: "Default stack size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global STACKSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
        prop Label :: "Stack segment for dynamic tasks"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: self.USETSK && (MEM.NOHEAPS == 0)
        prop Set :: (if (self.STACKSEG.iReqHeapCount > 0) {self.STACKSEG.iReqHeapCount--} , self.STACKSEG = $1, self.STACKSEG.iReqHeapCount++, "ok")
    }
    global PRIORITY :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "PRIORITY"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Label :: "Default task priority"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global CREATEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.CREATEFXN = $1, HOOK_KNL.createFxn = self.CREATEFXN, "ok")
        prop NoGen :: 1
    }
    global VCREATEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doCreate} else {self.CREATEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.DELETEFXN = $1, HOOK_KNL.deleteFxn = self.DELETEFXN, "ok")
        prop NoGen :: 1
    }
    global VDELETEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doDelete} else {self.DELETEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.EXITFXN = $1, HOOK_KNL.exitFxn = self.EXITFXN, "ok")
        prop NoGen :: 1
    }
    global VEXITFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doExit} else {self.EXITFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DOSWITCH :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "CALLSWITCHFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOSWITCH = $1, HOOK_KNL.callSwitchFxn = self.DOSWITCH, "ok")
        prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "SWITCHFXN"
        prop Visible :: 1
        prop NoGen :: 1
        prop Writable :: self.DOSWITCH && self.USETSK
        prop Set :: (self.VSWFXN = $1, HOOK_KNL.switchFxn = self.VSWFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global SWITCHFXN :: = (if (HOOK_KNL.iIsUsed) {$i = 0, scan ($a; HOOK) {if ($a.callSwitchFxn) {$i = 1} }, if ($i) {@__HOOK_doSwitch} else {0}} else {if (self.DOSWITCH) {self.VSWFXN} else {0}}) { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "CALLREADYFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOREADY = $1, HOOK_KNL.callReadyFxn = self.DOREADY, "ok")
        prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "READYFXN"
        prop Visible :: 1
        prop Writable :: self.DOREADY && self.USETSK
        prop NoGen :: 1
        prop Set :: (self.VRDYFXN = $1, HOOK_KNL.readyFxn = self.VRDYFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global READYFXN :: = (if (HOOK_KNL.iIsUsed) {$i = 0, scan ($a; HOOK) {if ($a.callReadyFxn) {$i = 1} }, if ($i) {@__HOOK_doReady} else {0}} else {if (self.DOREADY) {self.VRDYFXN} else {0}}) { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS :: = HOOK.gNumOf { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global TSKTICK :: "PRD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "PRD,User"
        prop Label :: "TSK tick driven by"
        prop JSName :: "DRIVETSKTICK"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
        prop Set :: (if ($1 != self.TSKTICK) {if ($1 == "PRD") {PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN, if (TSK.USETSK == 1) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @PRD_F_tick} } } , if ($1 == "User") {PRD.THOOKFXN = self.NOPFXN, if (PRD.gNumOf == 0) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @FXN_F_nop} } } , if ($1 != "PRD" && $1 != "User") {self.error("Invalid TSK tick driver selection")} } , self.TSKTICK = $1, "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Task function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG2 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 2"
        prop JSName :: "arg2"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG3 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 3"
        prop JSName :: "arg3"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG4 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 4"
        prop JSName :: "arg4"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG5 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 5"
        prop JSName :: "arg5"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG6 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 6"
        prop JSName :: "arg6"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG7 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 7"
        prop JSName :: "arg7"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iAUTOSTK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Automatically allocate stack"
        prop JSName :: "autoAllocateStack"
        prop Set :: (if (($1 == 1) && (self.iAUTOSTK == 0)) {self.iSTKSZ = TSK.STACKSIZE} , self.iAUTOSTK = $1, "ok")
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
    }
    inst iMANSTK :: @null { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Manually allocated stack"
        prop JSName :: "manualStack"
        prop Visible :: 1
        prop Writable :: self.iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: if GBL.DSPTYPE == 54 {0x01} else {0x02}
        prop Label :: "Stack size (MAUs)"
        prop JSName :: "stackSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: ($a = $1, if ($a < 32) {if (GBL.DSPSUBTYPE == 62) {self.error("Task stack size is too small.")} else {if ($a < 32) {self.error("Task stack size is too small.")} else {self.iSTKSZ = ($1 - ($1 - 1) % 8 + 7), GlobalStatus.gDirty = 1, "ok"}}} else {self.iSTKSZ = ($1 - ($1 - 1) % 8 + 7), GlobalStatus.gDirty = 1, "ok"})
    }
    inst iSTKSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
        prop Label :: "Stack Memory Segment"
        prop JSName :: "stackMemSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY { 
        prop Label :: "Priority"
        prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if (self == TSK_idle) {if ($1 == 0) {"ok"} else {self.error("Cannot change the priority of the idle task.")}} else {if ($1 == 0) {self.error("Priority 0 is reserved for the system idle task")} else {self.iPRI = $1, "ok"}})
    }
    inst iENV :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Environment pointer"
        prop JSName :: "envPointer"
        prop Visible :: 1
        prop Writable :: self.iDelUser != "TSK"
        prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't shut down system while this task is still running"
        prop JSName :: "exitFlag"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Task Name on Target"
        prop JSName :: "allocateTaskName"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iSTATREG :: = GBL.CACHE { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Label :: "Initial Status Register value"
        prop Visible :: 0
        prop Writable :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
    inst filter :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: self.STSGetMaxFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: self.STSGetSumFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: self.STSGetAvgFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst filtmaxmult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtmaxmult"
        prop NoGen :: 0
    }
    inst filtsummult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtsummult"
        prop NoGen :: 0
    }
    inst unittype :: self.uType() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "unittype"
        prop NoGen :: 0
    }
}

object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: @IDL_F_loop
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iSTKSEG :: IRAM
    param iPRI :: 0
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param Order :: 0
    param filter :: 2
    param maxformat :: "%g inst"
    param sumformat :: "%g inst"
    param avgformat :: "%.2f inst"
    param filtmaxmult :: 1
    param filtsummult :: 1
    param unittype :: 0
}

object KNL_swi :: SWI {
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This object cannot be deleted in DSP/BIOS."
    param function :: @_KNL_run
    param pri :: 0
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 0
    param filter :: 2
    param maxformat :: "%g inst"
    param sumformat :: "%g inst"
    param avgformat :: "%.2f inst"
    param filtmaxmult :: 1
    param filtsummult :: 1
    param unittype :: 0
}

type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (106)
    prop InstanceHelpTopic :: (206)
    prop InstancePropertyPage :: ("{586735F1-770B-11d0-A61F-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{586735F0-770B-11d0-A61F-0000C070F3E9}")
    prop objectSize :: (if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {$a = (2 * 4)} else {$a = (1 * 4)}, $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {%8t\n %1U_A_TABBEG = .;\n %3S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\0, name, _objSize, _linkString")
    prop GenLinkEpilogue :: ("%8t %1U_A_CALBEG = .;\n %4S\n %1U_A_CALEND = .;\n %1U_A_CALLEN = (. - %1U_A_CALBEG) / %2d;%4t\n} > %3s%5s%0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj")
    prop _linkString :: "*(.%1L)"
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {(if IDL.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if IDL.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if IDL.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop _nilBusyObj :: (if ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) {"IDL_busyObj = 0;\n"} else {""})
    prop _memSeg :: IDL.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop dataSize :: (self.objectSize() * (IDL.gNumOf + 1))
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop idlFxnSum :: ($a = 0, scan ($i; IDL) {$a += $i.cycles}, $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global AUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Auto calculate idle loop instruction count"
        prop JSName :: "AUTOCALCULATE"
        prop Visible :: 1
        prop Writable :: CLK.USETIMER
        prop Set :: (if ($1 == 1 && CLK.USETIMER == 0) {self.error("CLK must be enabled to do idle loop intruction count")} else {if ($1 == 1 && GBL.ENABLEINST == 0) {self.error("Real Time Analysis must be enabled to do idle loop instruction count")} else {self.AUTOCALCULATE = $1, "ok"}})
        prop NoGen :: 1
    }
    global USECLKIDLTIME :: = IDL.AUTOCALCULATE { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global USEIDLBUSYOBJ :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALIBRFXN :: = (if (IDL.AUTOCALCULATE == 1) {if TSK.USETSK {@IDL_F_stub} else {@IDL_F_calibrate}} else {@GBL_NULL}) { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALIBRERROR :: = (if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {6} else {0}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Error"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global LOOPOVERHEAD :: 0 { 
        prop Label :: "Idle Loop Instruction Count"
        prop JSName :: "LOOPINSTCOUNT"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.AUTOCALCULATE == 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst cycles :: 0 { 
        prop Label :: "CPU cycles"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 1
    }
    inst calibration :: 1 { 
        prop Label :: "Include in CPU load calibration"
        prop JSName :: "calibration"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to compute CPU load and can't be deleted"
    param function :: @IDL_F_busy
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to accumulate CPU load data and can't be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1
    prop Visible :: 0
    prop InstancePropertyPage :: ("{91BA37C0-98C3-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{91BA37C1-98C3-11d1-988B-0020AFEE33C6}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHwi :: HWI_UNUSED { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop MemberTest :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iIntrSelectNum :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

object Reset :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_RESET
    param iIntrSelectNum :: -1
}

object Non_Maskable :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_NMI
    param iIntrSelectNum :: -1
}

object Reserved :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_RESERVED0
    param iIntrSelectNum :: -1
}

object Host_Port_Host_to_DSP :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT13
    param iIntrSelectNum :: 0
}

object DSPINT :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 0
}

object Timer_0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT14
    param iIntrSelectNum :: 1
}

object Timer_1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT15
    param iIntrSelectNum :: 2
}

object EMIF_SDRAM_Timer :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT10
    param iIntrSelectNum :: 3
}

object External_Pin_4 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
    param iIntrSelectNum :: 4
}

object External_Pin_5 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT5
    param iIntrSelectNum :: 5
}

object External_Pin_6 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT6
    param iIntrSelectNum :: 6
}

object External_Pin_7 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT7
    param iIntrSelectNum :: 7
}

object EDMA_Controller :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT8
    param iIntrSelectNum :: 8
}

object HSRTDX11 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT11
    param iIntrSelectNum :: 10
}

object HSRTDX12 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT12
    param iIntrSelectNum :: 11
}

object MCSP_0_Transmit :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 12
}

object MCSP_0_Receive :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 13
}

object MCSP_1_Transmit :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 14
}

object MCSP_1_Receive :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 15
}

object HPI_PCI_to_DSP :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 0
}

object EMIFA_SDRAM_Timer :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iIntrSelectNum :: 3
}

object GPIO_Interrupt_4 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
    param iIntrSelectNum :: 4
}

object GPIO_Interrupt_5 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT5
    param iIntrSelectNum :: 5
}

object GPIO_Interrupt_6 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT6
    param iIntrSelectNum :: 6
}

object GPIO_Interrupt_7 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT7
    param iIntrSelectNum :: 7
}

object EDMA_Interrupt :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT8
    param iIntrSelectNum :: 8
}

object JTAGRTDX9 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 9
}

object EMU_DTDMA :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT9
    param iIntrSelectNum :: 9
}

object EMU_RTDX_RX :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT10
    param iIntrSelectNum :: 10
}

object EMU_RTDX_TX :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT11
    param iIntrSelectNum :: 11
}

object GPIO_Interrupt_0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 16
}

object MCSP_2_Transmit :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 17
}

object MCSP_2_Receive :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 18
}

object Timer_2 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT10
    param iIntrSelectNum :: 19
}

object EMIFB_SDRAM_Timer :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 20
}

object PCI_WAKEUP :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 21
}

object ICINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 22
}

object ICINT1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 23
}

object UTOPIA_Interrupt :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 23
}

object EMAC_MDIO_INT :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 24
}

object AXINT1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 24
}

object ARINT1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 25
}

object VPINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 25
}

object VPINT1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 26
}

object VPINT2 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 27
}

object AXINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 28
}

object ARINT0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 29
}

type LOG {
    isa ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (207)
    prop GlobalHelpTopic :: (107)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop objectSize :: (if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (10 * 4)} , if (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 54 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {$a = (6 * 4)} , $a)
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: ("%8t /* %0s buffer */\n .%0s$buf: align = 0x%1x {}\0, _objAlign")
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _objAlign :: if GBL.DSPTYPE == 55 {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2} else {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)}
    prop _objMemSeg :: self.bufseg
    prop LogType :: self.iType
    prop LogFormat :: self.iFormat
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"log.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far LOG_Obj %0r;\n\0"} else {"extern LOG_Obj %0r;\n\0"})
    prop dataSize :: ($d = 0, scan ($i; LOG) {if ($i.IsConfObj()) {$d += $i.buflen} , $d += self.objectSize()}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global TS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "timestamped LOGs"
        prop JSName :: "TS"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst buflen :: 64 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432"
        prop Label :: "buflen (words)"
        prop JSName :: "bufLen"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.buflen = $1, "ok")
    }
    inst logtype :: "circular" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "circular,fixed"
        prop Label :: "logtype"
        prop JSName :: "logType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iType :: "printf" { 
        prop Label :: "datatype"
        prop JSName :: "dataType"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "printf,raw data"
        prop Visible :: 1
        prop Writable :: if self.iType == "system" {0} else {1}
        prop NoGen :: 0
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" { 
        prop Label :: "format"
        prop JSName :: "format"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if self.iType == "raw data" {1} else {0}
        prop NoGen :: 0
    }
}

object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "LOG"
    param iDelMsg :: "LOG_system is a system log and cannot be deleted."
    param bufseg :: IRAM
    param buflen :: 64
    param logtype :: "circular"
    param iType :: "system"
    param iFormat :: "0x%x, 0x%x, 0x%x"
}

type PIP {
    isa ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (109)
    prop InstanceHelpTopic :: (209)
    prop name :: "PIP"
    prop maxObjs :: (32767)
    prop objectSize :: (if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (27 * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (34 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (30 * 4)} , if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (50 * 4)} , if (GBL.DSPTYPE == 62) {$a = (25 * 4)} , $a)
    prop dataSize :: ($b = 0, scan ($i; PIP) {if ($i.IsConfObj()) {$b += (12 + $i.framesize) * $i.numframes + self.objectSize()} }, $b)
    prop InstancePropertyPage :: ("{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}")
    prop localCreate :: ("ok")
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: (if self.bufalign > 0 {"%8t /* %0s buffer */\n .pip%1d: align = 0x%2x {}\0, _objId, _objAlign"} else {"%8t /* %0s buffer */\n .pip%1d: {}\0, _objId"})
    prop _placement :: (0x7fffffff / 2)
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign * 4
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop mkId :: (self.iId = self.gNextId++, self.gNumOf++, self.iId)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"pip.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PIP_Obj %0r;\n\0"} else {"extern PIP_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: 2 { 
        prop NoGen :: 0
    }
    global gNextId :: 0
    global OBJSIZE :: = self._objSize
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
    }
    inst bufalign :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "bufAlign"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 == 0) {$e = self.error("Cannot set align value to 0")} else {self.bufalign = $1}, $e)
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: if GBL.DSPTYPE == 62 {0x02} else {0x01 | 0x02}
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {GlobalStatus.gDirty = 1, self.framesize = $1, "ok"})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Pipes must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst monitor :: "reader" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "monitor"
        prop Enum :: "reader,writer,none"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst bufFrameAlign :: = self._objAlign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (310)
    prop InstanceHelpTopic :: (410)
    prop InstancePropertyPage :: ("{D01ACC04-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC05-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .sem: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (8 + 3)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (10 + 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (8 + 3)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (16 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (16 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (10 + 4)} , if (GBL.DSPTYPE == 28) {$a = (16 + 6)} , $a)
    prop dataSize :: (SEM.objectSize * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sem.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SEM_Obj %0r;\n\0"} else {"extern SEM_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Initial semaphore count"
        prop JSName :: "count"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (307)
    prop InstanceHelpTopic :: (407)
    prop InstancePropertyPage :: ("{0EB45D44-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D45-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,	_bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .mbx: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0 _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$que: align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize")
    prop _instMemSeg :: self.iMbxSeg
    prop _qElemSize :: (if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {$a = self.iMsgSize, if ($a & 0x1) {$a += 1} , (8 + $a) * self.iMbxLength * 2} else {if (GBL.DSPTYPE == 28) {$a = self.iMsgSize, if ($a & 0x1) {$a += 1} , (8 + $a) * self.iMbxLength} else {$a = self.iMsgSize, $b = GBL.DSPWORDSIZE / GBL.DSPCHARSIZE, $c = $a & ($b - 1), if ($c != 0) {$a = $a + ($b - $c)} , (8 + $a) * self.iMbxLength}})
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (29)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (28)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (24)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (46)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (46)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (28)} , if (GBL.DSPTYPE == 28) {$a = (46)} , $a)
    prop dataSize :: ($d = 0, scan ($i; MBX) {$d += (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + self.objectSize())}, $d)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"mbx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far MBX_Obj %0r;\n\0"} else {"extern MBX_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iMsgSize :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Message Size"
        prop JSName :: "messageSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Message size cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMsgSize = $1, "ok"})
    }
    inst iMbxLength :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Mailbox Length"
        prop JSName :: "length"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Mailbox length cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMbxLength = $1, "ok"})
    }
    inst iMbxSeg :: MBX.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Element memory segment"
        prop JSName :: "elementSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (309)
    prop InstanceHelpTopic :: (409)
    prop InstancePropertyPage :: ("{D01ACC01-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC02-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .que: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (2)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (2)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (2)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (2)} , if (GBL.DSPTYPE == 28) {$a = (4)} , $a)
    prop dataSize :: (QUE.objectSize * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"que.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far QUE_Obj %0r;\n\0"} else {"extern QUE_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (306)
    prop InstanceHelpTopic :: (406)
    prop InstancePropertyPage :: ("{0EB45D40-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D41-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .lck: {}")
    prop _objAllocDesc :: ("%8t .LCK$obj: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (10)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (12)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (10)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (20)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (20)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (12)} , if (GBL.DSPTYPE == 28) {$a = (20)} , $a)
    prop dataSize :: (LCK.objectSize * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"lck.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far LCK_Obj %0r;\n\0"} else {"extern LCK_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type STS {
    isa ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (212)
    prop GlobalHelpTopic :: (112)
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop localInit :: (if (PRD.CALLBACKOBJ != nil) {self.error("STS initialization failure")} , PRD.CALLBACKOBJ = STS)
    prop objectSize :: ((4 * 4))
    prop _placement :: (0x7fffffff / 2)
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: STS.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop dataSize :: (self.objectSize() * (STS.gNumOf + STS.gNumEmbed))
    prop maxObjs :: (32767)
    prop InstancePropertyPage :: ("{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: (self.format)
    prop STSGetSumFmt :: (self.format)
    prop STSGetAvgFmt :: ("%.2f")
    prop STSFilterSum :: ((self.iA * $1 + self.iB * $2) / (1.0 * self.iC))
    prop STSFilterMax :: ((self.iA * $1 + self.iB) / (1.0 * self.iC))
    prop HighTimeBased :: (if self.unittype == "High resolution time based" {1} else {0})
    prop LowTimeBased :: (if self.unittype == "Low resolution time based" {1} else {0})
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sts.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far STS_Obj %0r;\n\0"} else {"extern STS_Obj %0r;\n\0"})
    prop modifiable :: ((if (self.iDelUser == "USER" || self.iDelUser == "HWI") {1} else {0}))
    prop untype :: (if (self.unittype == "Not time based") {$a = 2} , if (self.unittype == "High resolution time based") {$a = 0} , if (self.unittype == "Low resolution time based") {$a = 1} , $a)
    prop optype :: (if (self.operation == "Nothing") {$a = 0} , if (self.operation == "A * x") {$a = 1} , if (self.operation == "A * x + B") {$a = 2} , if (self.operation == "(A * x + B) / C") {$a = 3} , $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst prev :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop JSName :: "previousVal"
        prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
        prop Set :: (self.prev = $1, self.prevlow = $1 & 0xffff, self.prevhigh = ($1 >> 16) & 0xffff, "ok")
    }
    inst format :: "%g" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "format"
        prop NoGen :: 1
    }
    inst filter :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: "%g" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: "%g" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: "%.2f" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst unittype :: "Not time based" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not time based,High resolution time based,Low resolution time based"
        prop Label :: "unit type"
        prop JSName :: "unitType"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (self.unittype = $1, if ($1 == "High resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "A * x"} else {if ($1 == "Low resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "A * x"} else {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "Nothing"}}, "ok")
    }
    inst operation :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
        prop Label :: "host operation"
        prop JSName :: "operation"
        prop Visible :: 1
        prop Writable :: ((self.unittype != "Low resolution time based") && self.modifiable())
        prop NoGen :: 1
        prop Set :: (self.operation = $1, if ($1 == "Nothing" && self.unittype != "High resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1} else {if ($1 == "A * x") {self.iB = 0, self.iC = 1} else {if ($1 == "A * x + B") {self.iC = 1} }}, "ok")
    }
    inst op :: = self.optype() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst uType :: = self.untype() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iA :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && !(self.unittype != "Not time based" || self.operation == "Nothing"))
        prop Label :: "A"
        prop JSName :: "numA"
        prop NoGen :: 0
    }
    inst iB :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && !(self.unittype == "Low resolution time based" || self.operation == "Nothing" || self.operation == "A * x"))
        prop Label :: "B"
        prop JSName :: "numB"
        prop NoGen :: 0
    }
    inst iC :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && (self.unittype == "Not time based" && self.operation == "(A * x + B) / C"))
        prop Label :: "C"
        prop JSName :: "numC"
        prop NoGen :: 0
    }
    inst prevhigh :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    inst prevlow :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (313)
    prop InstanceHelpTopic :: (413)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop AllocType :: (if self.PUTCFXN == @_UTL_doPutc {"2\0, _globalAllocDesc,	_memSeg, _midPlace, 	      _traceString, _traceSeg, _midPlace"} else {"1\0, _globalAllocDesc,	_memSeg, _midPlace"})
    prop _globalAllocDesc :: ("%8t .sys:     {}")
    prop _traceString :: ("%8t .trace: fill = 0x0  align = 0x4 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize")
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: SYS.TRACESIZE
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACESIZE :: 512 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%d"
        prop Style :: 0x01 | 0x02
        prop Label :: "Trace Buffer Size"
        prop JSName :: "TRACESIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TRACESEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Trace Buffer Memory"
        prop JSName :: "TRACESEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Abort Function"
        prop JSName :: "ABORTFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Error Function"
        prop JSName :: "ERRORFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Putc Function"
        prop JSName :: "PUTCFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "DIO,DGN,DHL,DPI"
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (311)
    prop InstanceHelpTopic :: (411)
    prop InstancePropertyPage :: ("{7C4C9A60-763E-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7C4C9A61-763E-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .SIO$bss: {%12t\n *(.SIO$bss)%8t\n }")
    prop _objAllocDesc :: ("%8t .SIO$obj: {%12t\n *(.SIO$obj)%8t\n }")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instBufDesc, _instBufSeg, _placement")
    prop _instBufDesc :: (if self.iAlign > 1 {"%8t .%0s$bufs: align = 0x%1x {}\0, _objAlign"} else {"%8t .%0s$bufs: {}"})
    prop _objAlign :: self.iAlign
    prop _instBufSeg :: self.iBufSegid
    prop defDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, break} }} }, $j)
    prop devList :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, scan ($a; DIO) {if ($a == $i) {$i.numTimeUse++} }, break} }} }, $j)
    prop setDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($i == $1) {$j = $i} }} }, $j)
    prop localCanCreate :: (if (self.defDev == nil) {self.error("A driver device must be created before creating a stream.")} else {"ok"})
    prop localDelete :: (scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, "ok")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sio.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SIO_Obj %0r;\n\0"} else {"extern SIO_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Only Issue/Reclaim Model"
        prop JSName :: "USEISSUERECLAIM"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.USEISSUERECLAIM = $1, if ($1 == 1) {scan ($i; SIO) {$i.iModelName = "Issue/Reclaim"}} , "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: SIO.devList { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop TypeTest :: $1.isDriver == 1
        prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
        prop Label :: "Device"
        prop JSName :: "deviceName"
        prop Set :: (if (($1.iIsTerminal == 0) && (self.iDevCtrlParam == "")) {self.error("To select a stacking device, enter first a terminal device in Device Control String")} else {if ($1.iIsVirtual == 1) {self.error("The device you have selected is a virtual instance, you must select a non-virtual device")} else {scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, scan ($b; DIO) {if ($b == $1) {$1.numTimeUse++} }, self.iDevice = self.setDev($1), "ok"}})
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevCtrlParam :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Device Control String"
        prop JSName :: "controlParameter"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevId :: = self.iDevice.iDevId
    inst iFxns :: = self.iDevice.iFxns
    inst iMode :: "input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "input,output"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufsize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Buffer size"
        prop JSName :: "bufSize"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iNbufs :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Number of buffers"
        prop JSName :: "numBufs"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufSegid :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Place buffers in memory segment"
        prop JSName :: "bufSegId"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iAlign :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
        prop Label :: "Buffer alignment"
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iFlush :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Flush"
        prop JSName :: "flush"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iModelName :: "Standard" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Standard,Issue/Reclaim"
        prop Label :: "Model"
        prop JSName :: "modelName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($e = "ok", if (self.USEISSUERECLAIM == 1) {if ($1 == "Standard") {$e = self.error("SIO Issue/Reclaim model support selected")} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}, $e)
    }
    inst iAllocBuf :: = self.iSaveAllocBuf { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Static Buffer(s)"
        prop JSName :: "allocStaticBuf"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (self.iSaveAllocBuf = $1, "ok")
    }
    inst iSaveAllocBuf :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
        prop Visible :: 0
        prop Writable :: 0
    }
    inst iTimeout :: = if self.iModel == "SIO_ISSUERECLAIM" {self.iSaveTimeout} else {-1} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timeout for I/O operation"
        prop JSName :: "timeout"
        prop Visible :: 1
        prop Writable :: self.iModel == "SIO_ISSUERECLAIM"
        prop Set :: (self.iSaveTimeout = $1, "ok")
    }
    inst iSaveTimeout :: -1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback function"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "callback function"
        prop JSName :: "callBackFxn"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
}

type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: self.USEGIO
    prop IsContainedIn :: IOF
    prop DependsOn :: "UDEV"
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (320)
    prop InstanceHelpTopic :: (420)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _midPlace")
    prop _globalAllocDesc :: ("%8t .gio:     {}")
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEGIO :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable General Input/Output Manager"
        prop JSName :: "ENABLEGIO"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CREATEFXN :: = if self.USEGIO == 1 {@_SEM_create} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create Function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global DELETEFXN :: = if self.USEGIO == 1 {@_SEM_delete} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete Function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global PENDFXN :: = if self.USEGIO == 1 {@_SEM_pend} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Pend Function"
        prop JSName :: "PENDFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global POSTFXN :: = if self.USEGIO == 1 {@_SEM_post} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Post Function"
        prop JSName :: "POSTFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
}

type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} , if (self.devCount() > 0) {"1\0, _devtableDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .dev: {}")
    prop _devtableDesc :: ("%8t .devtable: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    prop DependsOn :: "HWI"
    prop devCount :: ($i = nil, $a = 0, scan ($i; nil) {if ($i.isDriver == 1) {$a = $a + $i.gNumOf} }, $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "DEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (315)
    prop InstanceHelpTopic :: (415)
    prop InstancePropertyPage :: ("{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .udev: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (if self.fxnTableType == "DEV_Fxns" {"DEV_SIOTYPE"} else {"DEV_IOMTYPE"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iInit :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "init function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iInit = $1, self.initFxn = self.iInit, "ok")
    }
    inst iFxns :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function table ptr"
        prop JSName :: "fxnTable"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst fxnTableType :: "DEV_Fxns" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_Fxns,IOM_Fxns"
        prop Label :: "function table type"
        prop JSName :: "fxnTableType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst driverType :: = self._driverType { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
        prop Visible :: 0
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device id"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iDevId = $1, self.deviceId = self.iDevId, "ok")
    }
    inst iParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device params ptr"
        prop JSName :: "params"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst deviceId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst initFxn :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst iIsStacking :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stacking Device"
        prop JSName :: "stackingDevice"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device global data ptr"
        prop JSName :: "deviceGlobalDataPtr"
        prop Visible :: 1
        prop Writable :: self.fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal :: = if self.fxnTableType == "DEV_Fxns" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "UDEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (319)
    prop InstanceHelpTopic :: (419)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dio: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop isDriver :: (1)
    prop mdObject :: ($h = nil, $j = nil, scan ($h; UDEV) {if ($h.driverType == "DEV_IOMTYPE") {$j = $h, break} }, $j)
    prop localCanCreate :: (if (self.mdObject == nil) {self.error("An IOM type device must be created first.")} else {"ok"})
    prop numTsk :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 0) {$a = $a + $h.numTimeUse} }, $a)
    prop numSwi :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 1) {$a = $a + $h.numTimeUse} }, $a)
    prop functionTablePtr :: (if (self.STATIC) {if (self.useCallBackFxn) {@_DIO_cbStaticFxns} else {@_DIO_tskStaticFxns}} else {if (self.useCallBackFxn) {@_DIO_cbDynamicFxns} else {@_DIO_tskDynamicFxns}})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STATIC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Create all DIO Objects Statically"
        prop JSName :: "STATICCREATE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global NUMTSKBASE :: = self.numTsk { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "TSK based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global NUMSWIBASE :: = self.numSwi { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "SWI based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback version of DIO function table (for SWI)"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst fxnsTable :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst deviceName :: self.mdObject { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: UDEV
        prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label :: "device name"
        prop JSName :: "deviceName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst chanParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "channel parameters"
        prop JSName :: "chanParams"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst numTimeUse :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFxns :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (302)
    prop InstanceHelpTopic :: (402)
    prop InstancePropertyPage :: ("{054FE166-B014-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{054FE167-B014-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dgn: {}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: "user" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: if GBL.DSPARITHMETIC == "FLOAT" {"user,sine,random,constant,printFloat,printHex,printInt"} else {"user,sine,random,constant,printHex,printInt"}
        prop Label :: "Device category"
        prop JSName :: "device"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = $1, if ($a != self.iDevice) {self.iDevice = $a, self.iUserFxn = @_FXN_F_nop} , if ($a == "user") {self.iUserFxn = self.iSaveUserFxn} , if ($a == "printFloat") {self.iUserFxn = @_DGN_printFloat} , if ($a == "printHex") {self.iUserFxn = @_DGN_printHex} , if ($a == "printInt") {self.iUserFxn = @_DGN_printInt} , "ok")
    }
    inst iUseDefaults :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use default parameters"
        prop Visible :: 1
        prop JSName :: "useDefaultParam"
        prop Writable :: self.iDevice == "sine" || self.iDevice == "constant" || self.iDevice == "random" || self.iDevice == "user"
    }
    inst iDevId :: = if self.iDevice == "constant" {@DGN_CONST} else {if self.iDevice == "random" {@DGN_RAND} else {if self.iDevice == "sine" {@DGN_SINE} else {@DGN_USER}}} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Device ID"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iConstant :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Constant value"
        prop JSName :: "constant"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "constant" || self.iDevice == "user")
    }
    inst iRandSeed :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Seed value"
        prop JSName :: "seedValue"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandLower :: if GBL.DSPARITHMETIC == "FIXED" {-32767} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Lower limit"
        prop JSName :: "lowerLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandUpper :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Upper limit"
        prop JSName :: "upperLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iSineGain :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Gain"
        prop JSName :: "gain"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineFreq :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1000.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Frequency (Hz)"
        prop JSName :: "frequency"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSinePhase :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Phase (radians)"
        prop JSName :: "phase"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineRate :: if GBL.DSPARITHMETIC == "FIXED" {256} else {44000} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Sample rate (samples/sec)"
        prop JSName :: "rate"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iUserFxn :: if self.iDevice == "printFloat" {@_DGN_printFloat} else {if self.iDevice == "printHex" {@_DGN_printHex} else {if self.iDevice == "printInt" {@_DGN_printInt} else {@_FXN_F_nop}}} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
        prop Set :: (self.iUserFxn = $1, self.iSaveUserFxn = self.iUserFxn, "ok")
    }
    inst iSaveUserFxn :: @_FXN_F_nop { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iUserArg :: = 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function argument"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
    }
    inst iFxns :: @_DGN_FXNS { 
        prop NoGen :: 1
    }
}

type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (19)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (22)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (19)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (34)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (34)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (22)} , if (GBL.DSPTYPE == 28) {$a = (34)} , $a)
    prop dataSize :: (DHL.objectSize * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop localCanCreate :: (if (self.gChannelsAvailable > 0) {"ok"} else {self.warning("No HST channels are available for a new DHL device.")})
    prop localCreate :: (self.gChannelsAvailable--, self.seizeHSTChannel(self.iHSTChannel), "ok")
    prop seizeHSTChannel :: ($1.iDelUser = "DHL", $1.iDHLAvailable = 0, $1.notify = @_DHL_notify, $1.arg0 = $1.iId, "ok")
    prop localDelete :: (self.gChannelsAvailable++, self.releaseHSTChannel(self.iHSTChannel), "ok")
    prop releaseHSTChannel :: ($1.iDelUser = "USER", $1.iDHLAvailable = 1, $1.notify = @_FXN_F_nop, $1.arg0 = 0, "ok")
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: "%8t .dhl: {}"
    prop _memSeg :: self.OBJMEMSEG
    prop _placement :: (0x7fffffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gChannelsAvailable :: 0
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHSTChannel :: (scan ($i; HST) {if ($i.iDHLAvailable == 1) {$a = $i} }, $a) { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Underlying HST Channel"
        prop JSName :: "hstChannel"
        prop MemberType :: HST
        prop MemberTest :: (if (($1.iDHLAvailable == 1) || ($1 == self.iHSTChannel)) {1} else {0})
        prop Set :: (if ($1.iDHLAvailable != 1) {self.error("This channel is already in use.")} else {self.releaseHSTChannel(self.iHSTChannel), self.seizeHSTChannel($1), self.iHSTChannel = $1, "ok"})
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode :: = self.iHSTChannel.mode { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDevId :: = (self.iHSTChannel.iId) { 
        prop NoGen :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS { 
        prop NoGen :: 1
    }
}

type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (304)
    prop InstanceHelpTopic :: (404)
    prop InstancePropertyPage :: ("{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop localCreate :: (self.gCurDevId += 1, "ok")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gCurDevId :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop Set :: (self.error("DPI.iDevId parameter no longer settable, it is now handled automatically"))
    }
    inst iIsVirtual :: 0 { 
        prop Label :: "Allow virtual instances of this device."
        prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 1) {$a = "ok", $b = 1, scan ($i; SIO) {if ($i.iDevice == self) {$a = self.error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"), $b = 0} }, if ($b == 1) {self.iIsVirtual = 1} , $a} else {self.iIsVirtual = 0, "ok"})
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DPI_FXNS { 
        prop NoGen :: 1
    }
}

type MSGQ {
    isa Module
    prop Visible :: 1
    prop name :: "MSGQ"
    prop Label :: "MSGQ - Message Queue Manager"
    prop IsConfMod :: self.USEMSGQ
    prop IsContainedIn :: IOF
    prop DependsOn :: "GIO,SIO"
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (323)
    prop InstanceHelpTopic :: (423)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEMSGQ :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable MSGQ Manager"
        prop JSName :: "ENABLEMSGQ"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (318)
    prop InstanceHelpTopic :: (418)
    prop localCreate :: (if (self.gNumOf == 0) {HOOK_KNL.iIsUsed = 1, self.mkId(0)} , "ok")
    prop localDelete :: (if (self.gNumOf == 2) {HOOK_KNL.iIsUsed = 0, self.rmId} , "ok")
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global KNLID :: = (HOOK_KNL.Order - 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst initFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Initialization function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "createFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "deleteFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "exitFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "callSwitchFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "switchFxn"
        prop Visible :: 1
        prop Writable :: self.callSwitchFxn
    }
    inst callReadyFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "callReadyFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "readyFxn"
        prop Visible :: 1
        prop Writable :: self.callReadyFxn
    }
    inst Order :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object HOOK_KNL :: HOOK {
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: @_FXN_F_nop
    param deleteFxn :: @_FXN_F_nop
    param exitFxn :: @_FXN_F_nop
    param callSwitchFxn :: 0
    param switchFxn :: @_FXN_F_nop
    param callReadyFxn :: 0
    param readyFxn :: @_FXN_F_nop
    param Order :: 1
    param iPri :: 0
}

object SDRAM :: MEM {
    param iComment :: "This object defines space for the DSP's off-chip memory"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: -2147483648
    param len :: 16777216
    param iAllocHeap :: 1
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object IRAM :: MEM {
    param iComment :: "Internal L2 memory"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 0
    param len :: 1048576
    param iAllocHeap :: 1
    param iHeapSize :: 524288
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 3
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

