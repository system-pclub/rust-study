error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:7:12
   |
LL | const CST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `-D clippy::type-complexity` implied by `-D warnings`

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:8:12
   |
LL | static ST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:11:8
   |
LL |     f: Vec<Vec<Box<(u32, u32, u32, u32)>>>,
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:14:11
   |
LL | struct TS(Vec<Vec<Box<(u32, u32, u32, u32)>>>);
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:17:11
   |
LL |     Tuple(Vec<Vec<Box<(u32, u32, u32, u32)>>>),
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:18:17
   |
LL |     Struct { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> },
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:22:14
   |
LL |     const A: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:23:30
   |
LL |     fn impl_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:27:14
   |
LL |     const A: Vec<Vec<Box<(u32, u32, u32, u32)>>>;
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:28:14
   |
LL |     type B = Vec<Vec<Box<(u32, u32, u32, u32)>>>;
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:29:25
   |
LL |     fn method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:30:29
   |
LL |     fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:33:15
   |
LL | fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> {
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:37:14
   |
LL | fn test2(_x: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> $DIR/complex_types.rs:40:13
   |
LL |     let _y: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![];
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to 15 previous errors

